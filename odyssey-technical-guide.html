<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Odyssey-Api Technical Deep Dive</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#1f6feb',
                primaryTextColor: '#e6edf3',
                primaryBorderColor: '#58a6ff',
                lineColor: '#8b949e',
                secondaryColor: '#238636',
                tertiaryColor: '#161b22',
                noteTextColor: '#e6edf3',
                noteBkgColor: '#161b22',
                noteBorderColor: '#30363d',
                actorTextColor: '#e6edf3',
                actorBkg: '#1f6feb',
                actorBorder: '#58a6ff',
                signalColor: '#e6edf3',
                labelBoxBkgColor: '#161b22',
                labelBoxBorderColor: '#30363d',
                labelTextColor: '#e6edf3',
                sectionBkgColor: '#161b22',
                altSectionBkgColor: '#0d1117',
                taskBkgColor: '#1f6feb',
                taskTextColor: '#e6edf3',
                taskBorderColor: '#58a6ff',
                activeTaskBkgColor: '#238636',
                activeTaskBorderColor: '#3fb950',
                gridColor: '#30363d',
                doneTaskBkgColor: '#238636',
                doneTaskBorderColor: '#3fb950',
                fontSize: '14px'
            },
            flowchart: { curve: 'basis', padding: 20, htmlLabels: true },
            sequence: { actorMargin: 60, messageMargin: 40, mirrorActors: false }
        });
    </script>
    <style>
        :root {
            --bg: #0d1117;
            --surface: #161b22;
            --border: #30363d;
            --text: #e6edf3;
            --text-muted: #8b949e;
            --accent: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #d29922;
            --accent-red: #f85149;
            --accent-purple: #bc8cff;
            --code-bg: #0d1117;
            --sidebar-bg: #010409;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        @media (prefers-reduced-motion: reduce) {
            html { scroll-behavior: auto; }
            *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
        }
        body {
            font-family: var(--font-sans);
            font-size: 1rem;
            background: var(--bg);
            color: var(--text);
            line-height: 1.75;
            display: flex;
        }
        /* Sidebar Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 300px;
            height: 100vh;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px 0;
            z-index: 100;
        }
        nav h2 {
            padding: 0 20px;
            color: var(--accent);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }
        nav ul { list-style: none; }
        nav ul li a {
            display: block;
            padding: 6px 20px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 14px;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }
        nav ul li a:hover {
            color: var(--text);
            background: var(--surface);
            border-left-color: var(--accent);
        }
        nav ul li a:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        nav .section-title {
            padding: 15px 20px 5px;
            color: var(--accent);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }
        /* Main Content */
        main {
            margin-left: 300px;
            max-width: 960px;
            padding: clamp(1.5rem, 4vw, 2.5rem) clamp(1.5rem, 5vw, 3.75rem);
            width: calc(100% - 300px);
        }
        h1 {
            font-size: 36px;
            margin-bottom: 10px;
            color: var(--text);
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
        }
        h2 {
            font-size: 28px;
            margin-top: 50px;
            margin-bottom: 20px;
            color: var(--text);
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        h3 {
            font-size: 22px;
            margin-top: 35px;
            margin-bottom: 15px;
            color: var(--accent);
        }
        h4 {
            font-size: 18px;
            margin-top: 25px;
            margin-bottom: 10px;
            color: var(--accent-purple);
        }
        p { margin-bottom: 16px; color: var(--text); }
        .subtitle {
            font-size: 18px;
            color: var(--text-muted);
            margin-bottom: 30px;
        }
        /* Code Blocks */
        pre {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 15px 0 25px;
            font-size: 13px;
            line-height: 1.6;
        }
        code {
            font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', Consolas, monospace;
            font-size: 13px;
        }
        p code, li code, td code {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 12px;
            color: var(--accent);
        }
        /* Keyword highlighting (manual) */
        .kw { color: #ff7b72; }
        .fn { color: #d2a8ff; }
        .str { color: #a5d6ff; }
        .cmt { color: #8b949e; font-style: italic; }
        .type { color: #79c0ff; }
        .num { color: #79c0ff; }
        .ann { color: #ffa657; }
        /* Callout Boxes */
        .callout {
            border-radius: 8px;
            padding: 16px 20px;
            margin: 20px 0;
            border-left: 4px solid;
        }
        .callout-info {
            background: rgba(88, 166, 255, 0.08);
            border-left-color: var(--accent);
        }
        .callout-warn {
            background: rgba(210, 153, 34, 0.08);
            border-left-color: var(--accent-orange);
        }
        .callout-success {
            background: rgba(63, 185, 80, 0.08);
            border-left-color: var(--accent-green);
        }
        .callout-danger {
            background: rgba(248, 81, 73, 0.08);
            border-left-color: var(--accent-red);
        }
        .callout-title {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 14px;
        }
        .callout-info .callout-title { color: var(--accent); }
        .callout-warn .callout-title { color: var(--accent-orange); }
        .callout-success .callout-title { color: var(--accent-green); }
        .callout-danger .callout-title { color: var(--accent-red); }
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0 25px;
            font-size: 14px;
        }
        th, td {
            padding: 10px 14px;
            text-align: left;
            border: 1px solid var(--border);
        }
        th {
            background: var(--surface);
            color: var(--accent);
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        td { color: var(--text); }
        tr:hover td { background: rgba(88, 166, 255, 0.04); }
        /* Lists */
        ul, ol { margin: 10px 0 20px 30px; }
        li { margin-bottom: 8px; color: var(--text); }
        /* Diagram-like boxes */
        .flow-diagram {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.8;
            color: var(--text-muted);
        }
        .flow-diagram .highlight { color: var(--accent); font-weight: bold; }
        .flow-diagram .green { color: var(--accent-green); }
        .flow-diagram .orange { color: var(--accent-orange); }
        .flow-diagram .red { color: var(--accent-red); }
        /* Mermaid diagram containers */
        .mermaid-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px 15px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .mermaid-container .mermaid {
            display: flex;
            justify-content: center;
        }
        .mermaid-container .mermaid svg {
            max-width: 100%;
            height: auto;
        }
        .mermaid-label {
            color: var(--accent);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
        /* Card grid for merged content */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }
        .card h4 {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .card ul { margin-left: 16px; }
        .card li { margin: 4px 0; font-size: 14px; }
        .card code { font-size: 12px; }
        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .badge-mono { background: rgba(63,185,80,0.15); color: var(--accent-green); }
        .badge-flux { background: rgba(188,140,255,0.15); color: var(--accent-purple); }
        .badge-cron { background: rgba(210,153,34,0.15); color: var(--accent-orange); }
        .badge-asb { background: rgba(88,166,255,0.15); color: var(--accent); }
        /* Separator */
        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 40px 0;
        }
        /* Scroll margin for anchor targets */
        [id] { scroll-margin-top: 20px; }

        /* Mobile nav toggle */
        .nav-toggle {
            display: none;
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1001;
            width: 48px;
            height: 48px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--sidebar-bg);
            color: var(--text);
            cursor: pointer;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            transition: background 0.2s, color 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .nav-toggle:hover { background: var(--surface); color: var(--accent); }
        .nav-toggle:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
        .nav-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 99;
            opacity: 0;
            transition: opacity 0.25s;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .nav-toggle { display: flex; }
            .nav-overlay {
                display: block;
                pointer-events: none;
            }
            body.nav-open .nav-overlay {
                opacity: 1;
                pointer-events: auto;
            }
            nav {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                box-shadow: 4px 0 24px rgba(0,0,0,0.4);
            }
            body.nav-open nav { transform: translateX(0); }
            main { margin-left: 0; padding: 1.25rem 1.25rem 2rem; }
        }
        @media (max-width: 600px) {
            main { padding: 1rem 1rem 1.5rem; }
            h1 { font-size: 1.75rem; }
            h2 { font-size: 1.5rem; }
            h3 { font-size: 1.25rem; }
            pre { font-size: 12px; padding: 1rem; }
        }

        /* ===== LEARNING-ORIENTED ANIMATIONS ===== */

        /* Reading Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--accent-purple), var(--accent-green));
            z-index: 1000;
            transition: width 0.15s linear;
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.5);
        }

        /* Scroll Reveal: elements fade in as they enter viewport */
        .reveal {
            opacity: 0;
            transform: translateY(32px);
            transition: opacity 0.7s cubic-bezier(0.22, 1, 0.36, 1), transform 0.7s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Staggered table row reveals */
        .reveal-stagger tr td,
        .reveal-stagger tr th {
            opacity: 0;
            transform: translateX(-18px);
            transition: opacity 0.45s ease, transform 0.45s ease;
        }
        .reveal-stagger.visible tr td,
        .reveal-stagger.visible tr th {
            opacity: 1;
            transform: translateX(0);
        }
        .reveal-stagger.visible tr:nth-child(1) td,
        .reveal-stagger.visible tr:nth-child(1) th { transition-delay: 0s; }
        .reveal-stagger.visible tr:nth-child(2) td { transition-delay: 0.06s; }
        .reveal-stagger.visible tr:nth-child(3) td { transition-delay: 0.12s; }
        .reveal-stagger.visible tr:nth-child(4) td { transition-delay: 0.18s; }
        .reveal-stagger.visible tr:nth-child(5) td { transition-delay: 0.24s; }
        .reveal-stagger.visible tr:nth-child(6) td { transition-delay: 0.30s; }
        .reveal-stagger.visible tr:nth-child(7) td { transition-delay: 0.36s; }
        .reveal-stagger.visible tr:nth-child(8) td { transition-delay: 0.42s; }
        .reveal-stagger.visible tr:nth-child(9) td { transition-delay: 0.48s; }
        .reveal-stagger.visible tr:nth-child(10) td { transition-delay: 0.54s; }
        .reveal-stagger.visible tr:nth-child(11) td { transition-delay: 0.60s; }
        .reveal-stagger.visible tr:nth-child(12) td { transition-delay: 0.66s; }
        .reveal-stagger.visible tr:nth-child(13) td { transition-delay: 0.72s; }
        .reveal-stagger.visible tr:nth-child(14) td { transition-delay: 0.78s; }
        .reveal-stagger.visible tr:nth-child(15) td { transition-delay: 0.84s; }

        /* Active nav link with animated indicator */
        nav ul li a.active {
            color: var(--text) !important;
            background: var(--surface);
            border-left-color: var(--accent) !important;
        }

        /* Callout subtle glow on entry */
        .callout.reveal.visible {
            animation: callout-entrance 1.6s ease-out;
        }
        @keyframes callout-entrance {
            0% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.25); }
            40% { box-shadow: 0 0 24px 4px rgba(88, 166, 255, 0.08); }
            100% { box-shadow: none; }
        }
        .callout-warn.reveal.visible { animation: callout-entrance-warn 1.6s ease-out; }
        @keyframes callout-entrance-warn {
            0% { box-shadow: 0 0 0 0 rgba(210, 153, 34, 0.25); }
            40% { box-shadow: 0 0 24px 4px rgba(210, 153, 34, 0.08); }
            100% { box-shadow: none; }
        }
        .callout-success.reveal.visible { animation: callout-entrance-success 1.6s ease-out; }
        @keyframes callout-entrance-success {
            0% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.25); }
            40% { box-shadow: 0 0 24px 4px rgba(63, 185, 80, 0.08); }
            100% { box-shadow: none; }
        }
        .callout-danger.reveal.visible { animation: callout-entrance-danger 1.6s ease-out; }
        @keyframes callout-entrance-danger {
            0% { box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.25); }
            40% { box-shadow: 0 0 24px 4px rgba(248, 81, 73, 0.08); }
            100% { box-shadow: none; }
        }

        /* Code block: line-by-line reveal on hover */
        pre {
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        pre:hover {
            border-color: rgba(88, 166, 255, 0.3);
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.05);
        }

        /* Flow diagram animated data particles */
        .flow-diagram {
            position: relative;
            transition: border-color 0.3s ease;
        }
        .flow-diagram:hover {
            border-color: rgba(88, 166, 255, 0.3);
        }

        /* Badge subtle hover animation */
        .badge {
            transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.25s ease;
            cursor: default;
        }
        .badge:hover {
            transform: scale(1.12);
            box-shadow: 0 0 12px rgba(88, 166, 255, 0.15);
        }

        /* Section number counters */
        .section-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            color: #fff;
            font-size: 14px;
            font-weight: 700;
            margin-right: 12px;
            flex-shrink: 0;
        }

        /* ===== INTERACTIVE REACTIVE PIPELINE VISUALIZER ===== */
        .pipeline-demo {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 28px;
            margin: 28px 0;
            position: relative;
            overflow: hidden;
        }
        .pipeline-demo::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent), var(--accent-purple), var(--accent-green));
            opacity: 0.6;
        }
        .pipeline-demo h4 {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pipeline-demo .demo-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent-purple);
            font-weight: 600;
            margin-bottom: 6px;
        }
        .pipeline-stages {
            display: flex;
            align-items: center;
            gap: 0;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .pipeline-stage {
            background: rgba(88, 166, 255, 0.06);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 16px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 13px;
            color: var(--accent);
            transition: all 0.4s ease;
            position: relative;
            min-width: 90px;
            text-align: center;
        }
        .pipeline-stage.active {
            background: rgba(88, 166, 255, 0.15);
            border-color: var(--accent);
            box-shadow: 0 0 16px rgba(88, 166, 255, 0.15);
            transform: scale(1.05);
        }
        .pipeline-stage.done {
            background: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        .pipeline-arrow {
            color: var(--text-muted);
            font-size: 18px;
            padding: 0 6px;
            transition: color 0.4s ease;
        }
        .pipeline-arrow.active {
            color: var(--accent);
        }
        .pipeline-arrow.done {
            color: var(--accent-green);
        }
        /* Data items flowing through the pipeline */
        .data-track {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            min-height: 38px;
            flex-wrap: wrap;
        }
        .data-item {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 36px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            padding: 0 8px;
        }
        .data-item.num { background: rgba(88, 166, 255, 0.15); color: var(--accent); border: 1px solid rgba(88, 166, 255, 0.3); }
        .data-item.str { background: rgba(188, 140, 255, 0.15); color: var(--accent-purple); border: 1px solid rgba(188, 140, 255, 0.3); }
        .data-item.obj { background: rgba(63, 185, 80, 0.15); color: var(--accent-green); border: 1px solid rgba(63, 185, 80, 0.3); }
        .data-item.filtered {
            opacity: 0.25;
            transform: scale(0.7);
            text-decoration: line-through;
        }
        .data-item.new-val {
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes pop-in {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }
        .demo-btn {
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 12px;
            font-family: inherit;
        }
        .demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(88, 166, 255, 0.3);
        }
        .demo-btn:active {
            transform: translateY(0);
        }
        .demo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .demo-explanation {
            margin-top: 12px;
            padding: 12px 16px;
            background: rgba(88, 166, 255, 0.04);
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.7;
            border-left: 3px solid var(--accent);
            min-height: 40px;
            transition: all 0.4s ease;
        }

        /* ===== EDS PIPELINE ANIMATED STAGES ===== */
        .eds-pipeline {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 28px;
            margin: 28px 0;
        }
        .eds-stage {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 4px;
            transition: all 0.6s ease;
            opacity: 0.4;
            border-left: 3px solid transparent;
        }
        .eds-stage.active {
            opacity: 1;
            background: rgba(88, 166, 255, 0.04);
            border-left-color: var(--accent);
        }
        .eds-stage.done {
            opacity: 1;
            border-left-color: var(--accent-green);
        }
        .eds-stage .stage-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
            background: var(--bg);
            border: 2px solid var(--border);
            transition: all 0.5s ease;
        }
        .eds-stage.active .stage-icon {
            border-color: var(--accent);
            box-shadow: 0 0 12px rgba(88, 166, 255, 0.2);
        }
        .eds-stage.done .stage-icon {
            border-color: var(--accent-green);
            background: rgba(63, 185, 80, 0.1);
        }
        .eds-stage .stage-content h5 {
            margin: 0 0 4px;
            font-size: 15px;
            color: var(--text);
        }
        .eds-stage .stage-content p {
            margin: 0;
            font-size: 13px;
            color: var(--text-muted);
        }
        .eds-connector {
            width: 2px;
            height: 20px;
            background: var(--border);
            margin-left: 35px;
            transition: background 0.6s ease;
        }
        .eds-connector.done {
            background: var(--accent-green);
        }

        /* ===== MONO LIFECYCLE VISUALIZER ===== */
        .lifecycle-demo {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 28px;
            margin: 28px 0;
        }
        .lifecycle-track {
            display: flex;
            align-items: center;
            gap: 0;
            margin: 20px 0 8px;
            position: relative;
        }
        .lifecycle-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 100px;
            position: relative;
            z-index: 1;
        }
        .lifecycle-circle {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border: 2px solid var(--border);
            background: var(--bg);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .lifecycle-circle.active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.25);
            transform: scale(1.15);
        }
        .lifecycle-circle.success {
            border-color: var(--accent-green);
            box-shadow: 0 0 20px rgba(63, 185, 80, 0.25);
            transform: scale(1.15);
        }
        .lifecycle-circle.error {
            border-color: var(--accent-red);
            box-shadow: 0 0 20px rgba(248, 81, 73, 0.25);
            transform: scale(1.15);
        }
        .lifecycle-label {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            text-align: center;
            transition: color 0.3s ease;
        }
        .lifecycle-label.active { color: var(--accent); }
        .lifecycle-label.success { color: var(--accent-green); }
        .lifecycle-label.error { color: var(--accent-red); }
        .lifecycle-line {
            flex: 1;
            height: 2px;
            background: var(--border);
            position: relative;
            transition: background 0.5s ease;
        }
        .lifecycle-line.active { background: var(--accent); }
        .lifecycle-line.success { background: var(--accent-green); }
        .lifecycle-line.error { background: var(--accent-red); }
        .lifecycle-data-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            top: -4px;
            left: 0;
            box-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            opacity: 0;
        }
        .lifecycle-data-particle.moving {
            opacity: 1;
            animation: particle-move 0.8s ease forwards;
        }
        @keyframes particle-move {
            0% { left: 0; }
            100% { left: calc(100% - 10px); }
        }

        /* ===== BLOCKING VS NON-BLOCKING COMPARISON ===== */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 24px 0;
        }
        @media (max-width: 800px) {
            .comparison-container { grid-template-columns: 1fr; }
        }
        .comparison-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        .comparison-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
        }
        .comparison-panel.blocking::before { background: var(--accent-red); }
        .comparison-panel.nonblocking::before { background: var(--accent-green); }
        .comparison-panel h5 {
            margin: 0 0 16px;
            font-size: 14px;
        }
        .comparison-panel.blocking h5 { color: var(--accent-red); }
        .comparison-panel.nonblocking h5 { color: var(--accent-green); }
        .thread-lane {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 6px 0;
            height: 28px;
        }
        .thread-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            width: 52px;
            text-align: right;
            flex-shrink: 0;
        }
        .thread-segment {
            height: 22px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.8);
            transition: all 0.5s ease;
            opacity: 0;
        }
        .thread-segment.visible { opacity: 1; }
        .thread-segment.work { background: var(--accent); }
        .thread-segment.wait { background: rgba(248, 81, 73, 0.3); border: 1px dashed var(--accent-red); color: var(--accent-red); }
        .thread-segment.idle { background: rgba(139, 148, 158, 0.15); }
        .thread-segment.work-green { background: var(--accent-green); }

        /* ===== KEY TAKEAWAY BOXES ===== */
        .key-takeaway {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.06), rgba(188, 140, 255, 0.06));
            border: 1px solid rgba(88, 166, 255, 0.2);
            border-radius: 12px;
            padding: 20px 24px;
            margin: 24px 0;
            position: relative;
            overflow: hidden;
        }
        .key-takeaway::before {
            content: 'KEY TAKEAWAY';
            position: absolute;
            top: 0;
            right: 0;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            color: #fff;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1.5px;
            padding: 3px 12px;
            border-radius: 0 12px 0 8px;
        }
        .key-takeaway p {
            font-size: 15px;
            line-height: 1.7;
            margin: 0;
        }
        .key-takeaway strong { color: var(--accent); }

        /* ===== SECTION DIVIDER WITH ANIMATION ===== */
        hr {
            position: relative;
            overflow: visible;
        }
        hr.reveal.visible {
            animation: hr-expand 0.8s ease-out;
        }
        @keyframes hr-expand {
            0% { width: 0; opacity: 0; }
            100% { width: 100%; opacity: 1; }
        }

        /* ===== FLOATING CHAPTER INDICATOR ===== */
        .chapter-indicator {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 18px;
            font-size: 12px;
            color: var(--text-muted);
            z-index: 99;
            transition: all 0.4s ease;
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .chapter-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }
        .chapter-indicator .ch-section {
            color: var(--accent);
            font-weight: 600;
        }
    </style>
</head>
<body>

<div class="progress-bar" id="progressBar"></div>
<div class="chapter-indicator" id="chapterIndicator">
    <span class="ch-section" id="chapterName"></span>
</div>

<button type="button" class="nav-toggle" id="navToggle" aria-label="Open table of contents" aria-expanded="false">☰</button>
<div class="nav-overlay" id="navOverlay" aria-hidden="true"></div>

<nav>
    <h2>Odyssey-Api Guide</h2>
    <div class="section-title">Overview</div>
    <ul>
        <li><a href="#overview">Project Overview</a></li>
        <li><a href="#architecture">Architecture &amp; Modules</a></li>
        <li><a href="#system-arch-diagram">System Architecture Diagram</a></li>
        <li><a href="#module-deps-diagram">Module Dependencies</a></li>
        <li><a href="#service-bus-diagram">Service Bus Topology</a></li>
    </ul>
    <div class="section-title">Data Flows</div>
    <ul>
        <li><a href="#eds-import-pipeline">EDS Import Pipeline</a></li>
        <li><a href="#inventory-deltas">Inventory Deltas</a></li>
        <li><a href="#safety-check">15K Safety Check</a></li>
        <li><a href="#lease-expiries">Lease Expiries</a></li>
        <li><a href="#field-preservation">Field Preservation</a></li>
        <li><a href="#leasing-flow-diagram">Leasing Update Flow</a></li>
        <li><a href="#cart-flow-diagram">Cart Availability Flow</a></li>
        <li><a href="#search-flow-diagram">Search Query Flow</a></li>
        <li><a href="#tech-stack">Technology Stack</a></li>
    </ul>
    <div class="section-title">Project Reactor</div>
    <ul>
        <li><a href="#reactor-intro">What is Project Reactor?</a></li>
        <li><a href="#mono-flux">Mono vs Flux</a></li>
        <li><a href="#reactive-chains">Building Reactive Chains</a></li>
        <li><a href="#reactor-operators">Key Operators Explained</a></li>
        <li><a href="#reactive-dao">Reactive DAOs in Practice</a></li>
        <li><a href="#reactive-error">Error Handling in Reactor</a></li>
        <li><a href="#blockhound">BlockHound: Never Block!</a></li>
        <li><a href="#coroutines-reactor">Coroutines + Reactor Bridge</a></li>
    </ul>
    <div class="section-title">Cron Jobs</div>
    <ul>
        <li><a href="#cron-overview">Cron System Overview</a></li>
        <li><a href="#cron-scheduler">ScheduledTasks Entry Point</a></li>
        <li><a href="#cron-eds">EDS Vehicle Import Pipeline</a></li>
        <li><a href="#cron-leasing">Lease Expiry Processing</a></li>
        <li><a href="#cron-region">Postal Code Region Sync</a></li>
        <li><a href="#cron-cleanup">Database Cleanup Jobs</a></li>
        <li><a href="#cron-metrics">Metric Updates</a></li>
    </ul>
    <div class="section-title">Azure Integrations</div>
    <ul>
        <li><a href="#azure-blob">Azure Blob Storage</a></li>
        <li><a href="#azure-sb">Azure Service Bus</a></li>
        <li><a href="#azure-sb-consumer">Consumer Module</a></li>
        <li><a href="#azure-sb-availability">Availability Module</a></li>
    </ul>
    <div class="section-title">MongoDB</div>
    <ul>
        <li><a href="#mongo-config">KMongo Reactive Config</a></li>
        <li><a href="#mongo-dao">VehicleDao Pattern</a></li>
        <li><a href="#mongo-temp">Temp Import Strategy</a></li>
        <li><a href="#mongo-aggregation">Aggregation Pipeline DSL</a></li>
    </ul>
    <div class="section-title">Testing</div>
    <ul>
        <li><a href="#testing-overview">Testing Stack</a></li>
        <li><a href="#testing-stepverifier">StepVerifier Deep Dive</a></li>
        <li><a href="#testing-mockk">MockK Patterns</a></li>
        <li><a href="#testing-examples">Full Test Examples</a></li>
    </ul>
    <div class="section-title">APIs</div>
    <ul>
        <li><a href="#api-endpoints">API Overview</a></li>
        <li><a href="#graphql-queries">GraphQL Queries</a></li>
        <li><a href="#rest-endpoints">REST Endpoints</a></li>
        <li><a href="#graphql-mutations">GraphQL Mutations</a></li>
        <li><a href="#search-scoring">Search Scoring</a></li>
    </ul>
    <div class="section-title">Data Models</div>
    <ul>
        <li><a href="#data-models">Data Models Overview</a></li>
        <li><a href="#vehicle-model">Vehicle Model</a></li>
        <li><a href="#mongo-collections">MongoDB Collections</a></li>
        <li><a href="#atlas-search">Atlas Search Indexes</a></li>
        <li><a href="#key-enums">Key Enums</a></li>
    </ul>
    <div class="section-title">Deployment</div>
    <ul>
        <li><a href="#deployment">Deployment &amp; CI/CD</a></li>
        <li><a href="#environments">Environments</a></li>
        <li><a href="#cicd-pipeline">CI/CD Pipeline</a></li>
        <li><a href="#deployed-services">Deployed Services</a></li>
        <li><a href="#docker-build">Docker Build</a></li>
        <li><a href="#iac">Infrastructure as Code</a></li>
    </ul>
    <div class="section-title">External Integrations</div>
    <ul>
        <li><a href="#ext-integrations">Integration Map</a></li>
        <li><a href="#internal-services">Internal Lithia Services</a></li>
        <li><a href="#thirdparty-services">Third-Party Services</a></li>
        <li><a href="#message-consumers">Message Consumers</a></li>
    </ul>
    <div class="section-title">Configuration</div>
    <ul>
        <li><a href="#spring-profiles">Spring Profiles</a></li>
        <li><a href="#config-classes">Configuration Classes</a></li>
    </ul>
</nav>

<script>
(function() {
    var toggle = document.getElementById('navToggle');
    var overlay = document.getElementById('navOverlay');
    var nav = document.querySelector('nav');
    if (!toggle || !overlay || !nav) return;
    function openNav() {
        document.body.classList.add('nav-open');
        toggle.setAttribute('aria-expanded', 'true');
        overlay.setAttribute('aria-hidden', 'false');
    }
    function closeNav() {
        document.body.classList.remove('nav-open');
        toggle.setAttribute('aria-expanded', 'false');
        overlay.setAttribute('aria-hidden', 'true');
    }
    toggle.addEventListener('click', function() {
        document.body.classList.toggle('nav-open');
        var isOpen = document.body.classList.contains('nav-open');
        toggle.setAttribute('aria-expanded', isOpen);
        overlay.setAttribute('aria-hidden', !isOpen);
    });
    overlay.addEventListener('click', closeNav);
    nav.querySelectorAll('a').forEach(function(a) {
        a.addEventListener('click', function() {
            if (window.innerWidth <= 1024) closeNav();
        });
    });
})();
</script>

<main>

<!-- ==================== OVERVIEW ==================== -->
<h1 id="overview" class="reveal">Odyssey-Api Technical Deep Dive</h1>
<p class="subtitle reveal">A comprehensive guide for JavaScript developers joining the Kotlin/Spring Boot reactive backend</p>

<p>
    Odyssey-Api is the backend that powers <strong>Driveway.com's Shop functionality</strong> &mdash; the vehicle search, inventory management,
    leasing, and availability system. Think of it as the engine behind every car listing you see on the website. It manages
    roughly <strong>100,000+ vehicle records</strong> stored in MongoDB, processes <strong>EDS inventory files every 30 minutes</strong>,
    and serves <strong>GraphQL queries</strong> for the frontend to search and display vehicles.
</p>

<div class="callout callout-info reveal">
    <div class="callout-title">For JavaScript Developers</div>
    <p>If you're coming from Node.js/Express, here's the mental model: Spring Boot is like Express on steroids with dependency injection.
    Kotlin is like TypeScript but for the JVM. Reactor's <code>Mono</code> and <code>Flux</code> are like JavaScript <code>Promise</code> and
    <code>Observable</code> (RxJS). MongoDB is accessed through KMongo (a Kotlin-friendly wrapper) instead of Mongoose.</p>
</div>

<hr>

<!-- ==================== ARCHITECTURE ==================== -->
<h2 id="architecture" class="reveal">Architecture &amp; Modules</h2>

<p>The project is organized as a <strong>monorepo with 9 Gradle subprojects</strong> (similar to a Node.js monorepo with workspaces).
Five of these deploy as separate microservices, while the others are shared libraries.</p>

<div class="flow-diagram reveal"><span class="highlight">Deployed Services (5 pods on AKS):</span>

 <span class="green">[routes]</span> ──── REST API + GraphQL Mutations ──── Port 8080 (/shop/)
 <span class="green">[search]</span> ──── GraphQL Queries ────────────── Port 8080 (/shop-graphql/)
 <span class="green">[cron]</span> ────── Scheduled Jobs ──────────────── No HTTP
 <span class="green">[consumer]</span> ── Service Bus Listener ──────────── No HTTP
 <span class="green">[availability]</span> Service Bus Listener ──────────── No HTTP

<span class="highlight">Shared Libraries (not deployed):</span>

 <span class="orange">[library]</span> ──── Models, DAOs, Clients, Config (used by ALL services)
 <span class="orange">[graphql-shared]</span> GraphQL types (used by routes + search)
 <span class="orange">[utilities]</span> ── Developer CLI tools
 <span class="orange">[tests]</span> ────── Integration tests (run post-deploy)</div>

<p>Every deployable service depends on <code>library</code>, which contains all the shared infrastructure:
MongoDB DAOs, external API clients, domain models, configuration beans, and the custom aggregation pipeline DSL.</p>

<h3>How the modules interact</h3>

<div class="flow-diagram reveal"><span class="highlight">External Data Flow:</span>

 EDS TSV Files (Azure Blob)
        │
        ▼
   <span class="green">[cron]</span> ── every 30 min ──▶ Parse TSV ──▶ Temp Collection ──▶ Merge to vehicleV3
        │                                                          │
        ├── Publish deltas ──▶ <span class="orange">inventory-delta-topic</span> ──▶ (F&amp;I)     │
        │                                                          │
        └── Apply lease expiries ─────────────────────────────────│
                                                                   │
                                                                   ▼
                                                            <span class="green">[MongoDB vehicleV3]</span>
                                                                   │
   <span class="green">[search]</span> ◀── GraphQL queries ── Frontend                       │
                                                                   │
   <span class="green">[consumer]</span> ◀── <span class="orange">leasing-incentives-topic</span> ──▶ Update leasing data  │
                                                                   │
   <span class="green">[availability]</span> ◀── <span class="orange">cart-status-update-topic</span> ──▶ purchasePending │</div>

<h3 id="system-arch-diagram">System Architecture Diagram</h3>

<div class="mermaid-container reveal">
<div class="mermaid-label">Full System Architecture</div>
<pre class="mermaid">
graph TB
    subgraph External["External Data Sources"]
        EDS["EDS TSV Files<br/>(Azure Blob)"]
        CART["Shopping Cart<br/>Service"]
        LEASE["Leasing &amp;<br/>Incentives Service"]
        FI["F&amp;I System<br/>(Finance &amp; Insurance)"]
    end

    subgraph AKS["AKS Cluster (5 Services)"]
        CRON["odyssey-cron<br/>Scheduled Jobs"]
        ROUTES["odyssey-api<br/>REST + GraphQL Mutations<br/>/shop/"]
        SEARCH["odyssey-search-graphql<br/>GraphQL Queries<br/>/shop-graphql/"]
        CONSUMER["odyssey-consumer<br/>Leasing Messages"]
        AVAIL["odyssey-availability-sub<br/>Cart Status"]
    end

    subgraph Azure["Azure Service Bus Topics"]
        DELTA["inventory-delta-topic"]
        LEASETOPIC["leasing-incentives-topic"]
        CARTTOPIC["cart-status-update-topic"]
    end

    subgraph Data["Data Layer"]
        MONGO[("MongoDB Atlas<br/>shopInventory<br/>vehicleV3")]
        ATLAS["Atlas Search<br/>shopSearch Index"]
    end

    subgraph Clients["Consumers"]
        WEB["Driveway.com<br/>Frontend"]
        ADMIN["Admin Tools"]
    end

    EDS -->|"GZIP TSV every 30min"| CRON
    CRON -->|"Parse, Stage, Merge"| MONGO
    CRON -->|"Publish ADD/UPDATE/DELETE"| DELTA
    DELTA -->|"Inventory changes"| FI

    LEASE -->|"Regional pricing"| LEASETOPIC
    LEASETOPIC --> CONSUMER
    CONSUMER -->|"Update vehicle.leasing"| MONGO

    CART -->|"Cart events"| CARTTOPIC
    CARTTOPIC --> AVAIL
    AVAIL -->|"Update purchasePending"| MONGO

    MONGO --- ATLAS
    ATLAS -->|"Full-text search"| SEARCH
    MONGO -->|"Direct queries"| SEARCH
    MONGO -->|"CRUD operations"| ROUTES

    WEB -->|"GraphQL queries"| SEARCH
    WEB -->|"REST + mutations"| ROUTES
    ADMIN -->|"Score weights, suppressions"| ROUTES

    style CRON fill:#238636,stroke:#3fb950,color:#fff
    style ROUTES fill:#1f6feb,stroke:#58a6ff,color:#fff
    style SEARCH fill:#1f6feb,stroke:#58a6ff,color:#fff
    style CONSUMER fill:#6e40c9,stroke:#bc8cff,color:#fff
    style AVAIL fill:#6e40c9,stroke:#bc8cff,color:#fff
    style MONGO fill:#d29922,stroke:#e3b341,color:#000
    style ATLAS fill:#d29922,stroke:#e3b341,color:#000
</pre>
</div>

<h3 id="module-deps-diagram">Module Dependency Graph</h3>

<div class="mermaid-container reveal">
<div class="mermaid-label">Gradle Module Dependencies</div>
<pre class="mermaid">
graph LR
    subgraph Deployed["Deployable Services"]
        routes["routes<br/>(REST + Mutations)"]
        search["search<br/>(GraphQL Queries)"]
        cron["cron<br/>(Scheduled Jobs)"]
        consumer["consumer<br/>(Leasing Messages)"]
        availability["availability<br/>(Cart Status)"]
    end

    subgraph Shared["Shared Libraries"]
        library["library<br/>(Models, DAOs, Clients, Config)"]
        graphql["graphql-shared<br/>(GraphQL Types)"]
    end

    subgraph Dev["Dev/Test"]
        utilities["utilities<br/>(CLI Tools)"]
        tests["tests<br/>(Integration Tests)"]
    end

    routes --> library
    routes --> graphql
    search --> library
    search --> graphql
    cron --> library
    consumer --> library
    availability --> library
    utilities --> library
    tests --> library

    style library fill:#d29922,stroke:#e3b341,color:#000
    style graphql fill:#d29922,stroke:#e3b341,color:#000
    style routes fill:#1f6feb,stroke:#58a6ff,color:#fff
    style search fill:#1f6feb,stroke:#58a6ff,color:#fff
    style cron fill:#238636,stroke:#3fb950,color:#fff
    style consumer fill:#6e40c9,stroke:#bc8cff,color:#fff
    style availability fill:#6e40c9,stroke:#bc8cff,color:#fff
</pre>
</div>

<h3 id="service-bus-diagram">Service Bus Topic Topology</h3>

<div class="mermaid-container reveal">
<div class="mermaid-label">Azure Service Bus Message Flows</div>
<pre class="mermaid">
graph LR
    subgraph Publishers["Publishers"]
        CRON["odyssey-cron"]
        LEASING_SVC["Leasing Service<br/>(external)"]
        CART_SVC["Cart Service<br/>(external)"]
    end

    subgraph Topics["Service Bus Topics"]
        T1["inventory-delta-topic<br/>TTL: 14 days"]
        T2["leasing-incentives-topic<br/>TTL: 2 days"]
        T3["cart-status-update-topic"]
        T4["vehicle-data-topic<br/>TTL: 15 min"]
    end

    subgraph Subscribers["Subscribers"]
        FI["F&amp;I System<br/>(external)"]
        CONSUMER["odyssey-consumer<br/>lease-consumer-sub"]
        AVAIL["odyssey-availability-sub<br/>vehicle-availability-subscriber-sub"]
    end

    CRON -->|"InventoryDelta JSON<br/>batches of 100"| T1
    T1 --> FI

    LEASING_SVC -->|"LeaseIncentivesMessage<br/>LEASING or INCENTIVE type"| T2
    T2 -->|"Lock: 5min, Retries: 5"| CONSUMER

    CART_SVC -->|"CartStatusUpdateMessage"| T3
    T3 -->|"Max retries: 60"| AVAIL

    style CRON fill:#238636,stroke:#3fb950,color:#fff
    style CONSUMER fill:#6e40c9,stroke:#bc8cff,color:#fff
    style AVAIL fill:#6e40c9,stroke:#bc8cff,color:#fff
    style T1 fill:#d29922,stroke:#e3b341,color:#000
    style T2 fill:#d29922,stroke:#e3b341,color:#000
    style T3 fill:#d29922,stroke:#e3b341,color:#000
    style T4 fill:#d29922,stroke:#e3b341,color:#000
</pre>
</div>

<!-- ===== EXPANDED: EDS IMPORT PIPELINE ===== -->

<h3 id="eds-import-pipeline">The EDS Import Pipeline (Step by Step)</h3>

<p>
    Every <strong>30 minutes</strong>, the <code>cron</code> module runs <code>runVehicleReaderImport()</code>.
    This is the heartbeat of the entire inventory system &mdash; it's how vehicles get into the database.
    Here's exactly what happens, stage by stage:
</p>

<div class="flow-diagram reveal">Stage 1: Find &amp; Validate File
   Azure Blob Storage (container: <span class="orange">inbound</span>, prefix: <span class="orange">CVP/Driveway-Merchandising-V2/</span>)
      │
      ▼
   Find newest GZIP TSV file ──▶ Validate (non-empty, parseable) ──▶ Download

Stage 2: Parse &amp; Stage to Temp Collection
   TSV File (tab-separated, ~90 columns per row)
      │
      ▼
   <span class="green">CsvToExtractedRowConverter</span> ──▶ EdsExtractedInventoryRow (one per vehicle)
      │
      ▼
   Convert to <span class="green">Vehicle</span> objects ──▶ Batch insert to <span class="orange">temp_vehicleV3_&lt;timestamp&gt;</span>
                                    (500 vehicles/batch, 5 concurrent semaphores)

Stage 3: Safety Check
   Count vehicles in temp collection  vs  Count vehicles in live vehicleV3
      │
      ▼
   If (liveCount - incomingCount) &gt;= <span class="red">15,000</span> ──▶ ABORT (DeleteCheckFailureException)
   Otherwise ──▶ Continue

Stage 4: Compute &amp; Publish Deltas
   Compare temp vs live by VIN ──▶ Classify each vehicle:
      • <span class="green">ADD</span>    = VIN in incoming file, NOT in live inventory
      • <span class="orange">UPDATE</span> = VIN in both, but price OR mileage changed
      • <span class="red">DELETE</span> = VIN in live inventory, NOT in incoming file
      │
      ▼
   Publish to <span class="orange">inventory-delta-topic</span> (batches of 100) ──▶ F&amp;I system

Stage 5: Merge to Live Collection
   For each vehicle in temp collection:
      │
      ▼
   Fetch matching live vehicle by VIN ──▶ Combine records:
      • Temp data wins for all EDS fields (price, mileage, specs, dealer, etc.)
      • <span class="green">PRESERVE</span> from live: leasing, purchasePending, manuallySuppressed
      │
      ▼
   Upsert merged vehicle to <span class="green">vehicleV3</span>

Stage 6: Mark &amp; Sweep
   Find vehicles where lastSeenJobId ≠ current runId
      │
      ▼
   Set status = <span class="red">DELETED</span>, record deletedJobId ──▶ (cleaned up hourly by separate cron)

Stage 7: Apply Lease Expiries
   Fetch all vehicles where leasing.canLease == true
      │
      ▼
   Filter out expired regionalPrices ──▶ Update canLease &amp; defaultPrice ──▶ Upsert</div>

<div class="mermaid-container reveal">
<div class="mermaid-label">EDS Import Sequence (Every 30 Minutes)</div>
<pre class="mermaid">
sequenceDiagram
    participant Scheduler as ScheduledTasks
    participant Reader as EdsVehicleReaderV2
    participant Blob as Azure Blob Storage
    participant Temp as temp_vehicleV3_*
    participant Live as vehicleV3
    participant SB as Service Bus
    participant FI as F&amp;I System
    participant Leasing as CronLeasing

    Scheduler->>Reader: runVehicleReaderImport()
    Reader->>Blob: Find newest TSV file
    Blob-->>Reader: GZIP TSV file

    rect rgb(35, 134, 54, 0.2)
        Note over Reader,Temp: Stage: Parse &amp; Upload
        Reader->>Reader: Parse TSV → Vehicle objects
        Reader->>Temp: Batch insert (500/batch, 5 concurrent)
    end

    rect rgb(210, 153, 34, 0.2)
        Note over Temp,Live: Stage: Safety Check
        Reader->>Temp: Count incoming vehicles
        Reader->>Live: Count live vehicles
        Reader->>Reader: Assert delta &lt; 15,000
    end

    rect rgb(31, 111, 235, 0.2)
        Note over Temp,FI: Stage: Compute &amp; Publish Deltas
        Reader->>Temp: Get incoming VINs
        Reader->>Live: Get existing VINs
        Reader->>Reader: Set operations → ADD/UPDATE/DELETE
        Reader->>SB: Publish deltas (batches of 100)
        SB->>FI: InventoryDelta messages
    end

    rect rgb(110, 64, 201, 0.2)
        Note over Temp,Live: Stage: Merge &amp; Cleanup
        Reader->>Live: Merge (preserve leasing, availability, suppressions)
        Reader->>Live: Mark missing vehicles as DELETED
        Reader->>Temp: Drop temp collection
    end

    Scheduler->>Leasing: applyLeaseExpiries()
    Leasing->>Live: Filter expired regional prices
    Leasing->>Live: Upsert updated vehicles
</pre>
</div>

<!-- ===== EXPANDED: INVENTORY DELTAS ===== -->

<h3 id="inventory-deltas">What Are Inventory Deltas &amp; Why Publish Them?</h3>

<p>
    When the cron module imports a new batch of vehicles, it doesn't just blindly overwrite the database.
    It first <strong>computes what changed</strong> between the incoming file and the current live inventory.
    These changes are called <strong>inventory deltas</strong>.
</p>

<h4>The Three Delta Types</h4>

<table>
    <tr><th>Action</th><th>Meaning</th><th>How It's Detected</th></tr>
    <tr>
        <td><code style="color: var(--accent-green)">ADD</code></td>
        <td>A brand new vehicle appeared in inventory</td>
        <td>VIN exists in the incoming file but <em>not</em> in the live <code>vehicleV3</code> collection</td>
    </tr>
    <tr>
        <td><code style="color: var(--accent-orange)">UPDATE</code></td>
        <td>An existing vehicle's price or mileage changed</td>
        <td>VIN exists in <em>both</em> collections, but <code>price</code> or <code>mileage</code> differs</td>
    </tr>
    <tr>
        <td><code style="color: var(--accent-red)">DELETE</code></td>
        <td>A vehicle is no longer in inventory (sold, transferred, etc.)</td>
        <td>VIN exists in live <code>vehicleV3</code> but <em>not</em> in the incoming file</td>
    </tr>
</table>

<h4>What Data Is in a Delta?</h4>

<p>
    A delta is a <strong>minimal projection</strong> of a Vehicle &mdash; only the fields the downstream system needs.
    This is defined by the <code>InventoryDelta</code> data class:
</p>

<pre><code><span class="kw">data class</span> <span class="type">InventoryDelta</span>(
    <span class="kw">val</span> vin: <span class="type">String</span>,
    <span class="kw">val</span> action: <span class="type">InventoryDeltaAction</span>,    <span class="cmt">// ADD, UPDATE, or DELETE</span>
    <span class="kw">val</span> vehicleId: <span class="type">String</span>,
    <span class="kw">val</span> priceInCents: <span class="type">Number?</span>,
    <span class="kw">val</span> msrp: <span class="type">Number?</span>,
    <span class="kw">val</span> mileage: <span class="type">Number</span>,
    <span class="kw">val</span> year: <span class="type">Number?</span>,
    <span class="kw">val</span> make: <span class="type">String</span>,
    <span class="kw">val</span> model: <span class="type">String?</span>,
    <span class="kw">val</span> vehicleCondition: <span class="type">String?</span>,
    <span class="kw">val</span> driveType: <span class="type">String?</span>,
    <span class="kw">val</span> fuelType: <span class="type">String?</span>,
    <span class="kw">val</span> dealerState: <span class="type">String</span>,
    <span class="kw">val</span> dealerZip: <span class="type">String?</span>,
    <span class="kw">val</span> hints: <span class="type">Hints?</span>
)</code></pre>

<p>
    Notice what's <em>not</em> included: no leasing data, no availability state, no images, no feature lists.
    The downstream system only needs to know <em>what changed</em> and the key vehicle identifiers.
</p>

<h4>Why Publish Deltas?</h4>

<p>
    The deltas are published to the <code>inventory-delta-topic</code> Azure Service Bus topic.
    The primary consumer is the <strong>F&amp;I (Finance &amp; Insurance) system</strong>, which needs to know:
</p>

<ul>
    <li><strong>ADD</strong> &mdash; "A new vehicle is available. We may need to prepare financing offers and insurance quotes for it."</li>
    <li><strong>UPDATE</strong> &mdash; "A vehicle's price or mileage changed. Recalculate any financing terms or payment estimates."</li>
    <li><strong>DELETE</strong> &mdash; "This vehicle left inventory. Stop offering financing for it."</li>
</ul>

<div class="callout callout-info reveal">
    <div class="callout-title">Why Not Just Let F&amp;I Read the Database?</div>
    <p>
        Publishing deltas via Service Bus is an <strong>event-driven architecture</strong> pattern.
        Instead of F&amp;I polling the database every few minutes asking "what changed?",
        the cron module <em>tells</em> F&amp;I exactly what changed. This is more efficient, real-time,
        and decouples the systems &mdash; F&amp;I doesn't need direct MongoDB access.
    </p>
</div>

<h4>How Deltas Are Computed (The Algorithm)</h4>

<p>The delta computation in <code>TempImportImpl.getInventoryDeltas()</code> works by set operations on VINs:</p>

<pre><code><span class="cmt">// Pseudocode for delta computation</span>
<span class="kw">val</span> incomingVins = getAllVins(tempCollection)    <span class="cmt">// VINs from the new EDS file</span>
<span class="kw">val</span> existingVins = getAllVins(liveCollection)    <span class="cmt">// VINs currently in vehicleV3</span>

<span class="cmt">// Set difference: incoming minus existing = new vehicles</span>
<span class="kw">val</span> adds = (incomingVins - existingVins)
    .map { fetchFromTemp(it).toDelta(<span class="type">ADD</span>) }

<span class="cmt">// Set difference: existing minus incoming = removed vehicles</span>
<span class="kw">val</span> deletes = (existingVins - incomingVins)
    .map { fetchFromLive(it).toDelta(<span class="type">DELETE</span>) }

<span class="cmt">// Intersection: vehicles in both → check for price/mileage changes</span>
<span class="kw">val</span> updates = (incomingVins intersect existingVins)
    .filter { vin ->
        <span class="kw">val</span> incoming = fetchFromTemp(vin)
        <span class="kw">val</span> existing = fetchFromLive(vin)
        incoming.price != existing.price || incoming.mileage != existing.mileage
    }
    .map { fetchFromTemp(it).toDelta(<span class="type">UPDATE</span>) }</code></pre>

<p>
    For UPDATE detection, overlapping VINs are processed in <strong>batches of 500</strong> with
    <strong>10 concurrent semaphore permits</strong> to avoid overwhelming MongoDB. Only
    <code>InventoryDelta.requiredVehicleFieldsProjection</code> (14 fields) is fetched per vehicle &mdash;
    not the full 50+ field Vehicle document.
</p>

<h4>Publishing Flow</h4>

<pre><code><span class="cmt">// From CronEdsVehicleImporter.getPublishDeltasFlow()</span>
tempImport.getInventoryDeltas()       <span class="cmt">// Compute all ADD/UPDATE/DELETE deltas</span>
    .chunked(<span class="num">100</span>)                    <span class="cmt">// Batch into groups of 100</span>
    .forEach { batch ->
        deltaTopic.sendMessages(batch) <span class="cmt">// Send to Azure Service Bus</span>
    }

<span class="cmt">// In laptop profile: DummyDeltaTopicSender just logs (no real messaging)</span>
<span class="cmt">// In dev/uat/prod: ServiceBusMessageSender serializes to JSON and sends</span></code></pre>

<div class="mermaid-container reveal">
<div class="mermaid-label">Delta Computation Flowchart</div>
<pre class="mermaid">
flowchart TD
    START["getInventoryDeltas()"] --> VINS1["Get VINs from<br/>temp collection"]
    START --> VINS2["Get VINs from<br/>live vehicleV3"]

    VINS1 --> ADD["incoming - existing<br/>= NEW VINs"]
    VINS2 --> ADD
    ADD --> ADD_DELTA["Create ADD deltas<br/>from temp collection"]

    VINS1 --> DEL["existing - incoming<br/>= REMOVED VINs"]
    VINS2 --> DEL
    DEL --> DEL_DELTA["Create DELETE deltas<br/>from live collection"]

    VINS1 --> OVERLAP["incoming ∩ existing<br/>= OVERLAPPING VINs"]
    VINS2 --> OVERLAP
    OVERLAP --> BATCH["Process in batches of 500<br/>(10 concurrent semaphores)"]
    BATCH --> CHECK{"price changed?<br/>OR<br/>mileage changed?"}
    CHECK -->|Yes| UPD_DELTA["Create UPDATE delta"]
    CHECK -->|No| SKIP["Skip (no change)"]

    ADD_DELTA --> COMBINE["Combine all deltas"]
    DEL_DELTA --> COMBINE
    UPD_DELTA --> COMBINE
    COMBINE --> PUBLISH["Publish in batches of 100<br/>to inventory-delta-topic"]

    style ADD_DELTA fill:#238636,stroke:#3fb950,color:#fff
    style DEL_DELTA fill:#da3633,stroke:#f85149,color:#fff
    style UPD_DELTA fill:#d29922,stroke:#e3b341,color:#000
    style PUBLISH fill:#1f6feb,stroke:#58a6ff,color:#fff
</pre>
</div>

<!-- ===== EXPANDED: THE 15,000 SAFETY CHECK ===== -->

<h3 id="safety-check">The 15,000 Delta Safety Check</h3>

<p>
    Before publishing deltas or merging to the live collection, the system performs a critical safety check.
    This protects against corrupted or truncated EDS files that could accidentally wipe out the inventory.
</p>

<div class="flow-diagram reveal">
   Live vehicleV3 count:  45,000 vehicles
   Incoming temp count:   44,500 vehicles
   Delta: 45,000 - 44,500 = <span class="green">500</span>  ──▶  ✓ Under 15,000 threshold. Proceed.

   ───────────────────────────────────────────────────────

   Live vehicleV3 count:  45,000 vehicles
   Incoming temp count:   20,000 vehicles  (corrupted/truncated file!)
   Delta: 45,000 - 20,000 = <span class="red">25,000</span>  ──▶  ✗ ABORT! DeleteCheckFailureException thrown.
                                           Job marked as SUSPICIOUS_FILE.</div>

<p>
    The threshold is configurable via <code>cron.suspiciousDeltaThreshold</code> (default: <strong>15,000</strong>).
    If a file would cause more than 15,000 vehicles to be deleted, it's almost certainly a data problem,
    not a legitimate inventory change.
</p>

<!-- ===== EXPANDED: LEASE EXPIRIES ===== -->

<h3 id="lease-expiries">Why Apply Lease Expiries?</h3>

<p>
    Leasing data on vehicles comes from a <em>separate</em> system via the <code>leasing-incentives-topic</code>
    (consumed by the <code>consumer</code> module). Each vehicle's <code>leasing</code> field contains:
</p>

<pre><code><span class="kw">data class</span> <span class="type">Leasing</span>(
    <span class="kw">val</span> canLease: <span class="type">Boolean</span>,                     <span class="cmt">// Is this vehicle currently leasable?</span>
    <span class="kw">val</span> defaultPrice: <span class="type">Long?</span>,                   <span class="cmt">// Fallback lease price (region 1)</span>
    <span class="kw">val</span> regionalPrices: <span class="type">List&lt;RegionData&gt;?</span>     <span class="cmt">// Per-region lease prices with expiration</span>
)

<span class="kw">data class</span> <span class="type">RegionData</span>(
    <span class="kw">val</span> regionId: <span class="type">Int</span>,
    <span class="kw">val</span> amountInCents: <span class="type">Long</span>,
    <span class="kw">val</span> expiresOn: <span class="type">String</span>                     <span class="cmt">// ISO-8601 instant, e.g. "2026-03-15T00:00:00Z"</span>
)</code></pre>

<p>
    The problem: leasing programs <strong>expire over time</strong>. A lease offer set up in January might expire
    in March. If no one actively cleans up the expired entries, the website would display stale or invalid
    lease prices to customers. That's why the cron module runs <code>CronLeasing.applyLeaseExpiries()</code>
    after every EDS import.
</p>

<h4>What the Lease Expiry Process Does</h4>

<div class="flow-diagram reveal">
   <span class="highlight">Before lease expiry check:</span>
   Vehicle VIN: 1HGCV1F34PA123456
   leasing:
     canLease: true
     defaultPrice: 35999  (region 1)
     regionalPrices:
       ├── regionId: 1,  amount: 35999,  expiresOn: "2026-01-15T00:00:00Z"  <span class="red">← EXPIRED</span>
       ├── regionId: 5,  amount: 38500,  expiresOn: "2026-04-01T00:00:00Z"  <span class="green">← still valid</span>
       └── regionId: 12, amount: 37200,  expiresOn: "2025-12-01T00:00:00Z"  <span class="red">← EXPIRED</span>

   ───────────────────────────────────────────────────────

   <span class="highlight">After lease expiry check:</span>
   Vehicle VIN: 1HGCV1F34PA123456
   leasing:
     canLease: true       <span class="cmt">← still true (at least one region is valid)</span>
     defaultPrice: null   <span class="cmt">← region 1 expired, so no default</span>
     regionalPrices:
       └── regionId: 5,  amount: 38500,  expiresOn: "2026-04-01T00:00:00Z"  <span class="green">← only survivor</span>

   ───────────────────────────────────────────────────────

   <span class="highlight">If ALL regions expire:</span>
   leasing:
     canLease: <span class="red">false</span>      <span class="cmt">← no more valid programs → vehicle is no longer leasable</span>
     defaultPrice: null
     regionalPrices: []</div>

<h4>The Algorithm</h4>

<ol>
    <li>Fetch all vehicles where <code>leasing.canLease == true</code></li>
    <li>For each vehicle, check every entry in <code>regionalPrices</code></li>
    <li>Filter out entries where <code>Instant.parse(expiresOn).isBefore(now)</code></li>
    <li>If any active programs remain: keep <code>canLease = true</code>, update <code>defaultPrice</code> to region 1's price (if still active)</li>
    <li>If <em>no</em> active programs remain: set <code>canLease = false</code>, clear <code>defaultPrice</code></li>
    <li>Upsert the updated vehicle back to <code>vehicleV3</code> (batches of 100)</li>
</ol>

<div class="callout callout-info reveal">
    <div class="callout-title">Why Not Let the Consumer Handle Expiry?</div>
    <p>
        The <code>consumer</code> module only processes <em>incoming</em> leasing messages &mdash; it adds or updates
        lease programs when new data arrives from the leasing system. But it doesn't proactively check for
        expirations. Lease programs expire passively over time, so a scheduled cleanup is needed. Running it
        on every 30-minute import cycle ensures expired offers are caught within at most 30 minutes of expiring.
    </p>
</div>

<div class="mermaid-container reveal">
<div class="mermaid-label">Lease Expiry Decision Flow</div>
<pre class="mermaid">
flowchart TD
    START["Fetch vehicles where<br/>leasing.canLease == true"] --> LOOP["For each vehicle"]
    LOOP --> CHECK["Check each entry in<br/>regionalPrices"]
    CHECK --> EXPIRED{"expiresOn<br/>before now?"}
    EXPIRED -->|Yes| REMOVE["Remove expired entry"]
    EXPIRED -->|No| KEEP["Keep active entry"]
    REMOVE --> REMAINING{"Any active<br/>entries left?"}
    KEEP --> REMAINING
    REMAINING -->|Yes| UPDLEASE["canLease = true<br/>defaultPrice = region 1 price<br/>(if region 1 still active)"]
    REMAINING -->|No| NOLEASE["canLease = false<br/>defaultPrice = null<br/>regionalPrices = empty"]
    UPDLEASE --> UPSERT["Upsert to vehicleV3<br/>(batches of 100)"]
    NOLEASE --> UPSERT

    style REMOVE fill:#da3633,stroke:#f85149,color:#fff
    style KEEP fill:#238636,stroke:#3fb950,color:#fff
    style NOLEASE fill:#da3633,stroke:#f85149,color:#fff
    style UPDLEASE fill:#238636,stroke:#3fb950,color:#fff
</pre>
</div>

<!-- ===== EXPANDED: FIELD PRESERVATION DURING MERGE ===== -->

<h3 id="field-preservation">Field Preservation During Merge</h3>

<p>
    When the cron module merges vehicles from the temp collection into the live <code>vehicleV3</code> collection,
    it faces a critical challenge: the EDS file only contains <em>inventory data</em> (specs, pricing, dealer info).
    But the live vehicles have additional state that comes from <em>other systems</em>:
</p>

<table>
    <tr><th>Field</th><th>Source</th><th>Why It Must Be Preserved</th></tr>
    <tr>
        <td><code>leasing</code></td>
        <td><code>consumer</code> module (via leasing-incentives-topic)</td>
        <td>Regional lease pricing arrives asynchronously from the leasing system. If overwritten, vehicles lose their lease offers until the next leasing message arrives.</td>
    </tr>
    <tr>
        <td><code>availability.purchasePending</code></td>
        <td><code>availability</code> module (via cart-status-update-topic)</td>
        <td>Indicates a customer has this vehicle in their cart. If overwritten, the vehicle would appear available when someone is actively purchasing it.</td>
    </tr>
    <tr>
        <td><code>manuallySuppressed</code></td>
        <td><code>routes</code> module (via REST API)</td>
        <td>Manually hidden by staff (e.g., reserved for VIP, pending recall). If overwritten, hidden vehicles would reappear on the website.</td>
    </tr>
</table>

<p>
    The merge process pairs each incoming vehicle with its live counterpart by VIN, then combines them:
    <strong>EDS fields from the incoming vehicle take priority</strong>, but the three preserved fields are
    carried over from the live vehicle. This ensures that a 30-minute inventory refresh never clobbers
    real-time state from other parts of the system.
</p>

<h3 id="leasing-flow-diagram">Leasing Update Flow</h3>

<p>When the external leasing service calculates new lease programs for vehicles, it publishes messages
to <code>leasing-incentives-topic</code>. The <code>consumer</code> module processes these asynchronously:</p>

<div class="mermaid-container reveal">
<div class="mermaid-label">Leasing Message Processing Sequence</div>
<pre class="mermaid">
sequenceDiagram
    participant Finance as Leasing Service
    participant SB as leasing-incentives-topic
    participant Consumer as odyssey-consumer
    participant Handler as LeaseHandler
    participant DB as MongoDB vehicleV3

    Finance->>SB: Publish LeaseIncentivesMessage<br/>(type: LEASING, vin, regions)
    SB->>Consumer: Deliver message<br/>(lock: 5min, retries: 5)

    Consumer->>Consumer: Route by message type
    alt type == LEASING
        Consumer->>Handler: handle(message)
        Handler->>DB: getByVin(vin)
        DB-->>Handler: Vehicle

        Handler->>Handler: Build Leasing object:<br/>sort regions by regionId<br/>set defaultPrice from region 1<br/>set canLease (NEW vehicles only)

        Handler->>DB: updateVehicleField(vin, leasing, newLeasing)
        Handler-->>Consumer: Success
    else type == INCENTIVE
        Consumer->>Consumer: Log warning (no-op)
    end

    Consumer->>SB: Acknowledge message
</pre>
</div>

<h3 id="cart-flow-diagram">Cart Availability Flow</h3>

<p>When a customer adds a vehicle to their shopping cart (or removes it), the cart service publishes an event.
The <code>availability</code> module updates the vehicle's <code>purchasePending</code> flag to prevent other customers
from purchasing the same vehicle simultaneously:</p>

<div class="mermaid-container reveal">
<div class="mermaid-label">Cart Status Update Sequence</div>
<pre class="mermaid">
sequenceDiagram
    participant Cart as Shopping Cart Service
    participant SB as cart-status-update-topic
    participant Avail as odyssey-availability-sub
    participant Handler as AvailabilityRequestHandler
    participant DB as MongoDB vehicleV3

    Cart->>SB: Publish CartStatusUpdateMessage<br/>(vin, purchasePending: true/false)
    SB->>Avail: Deliver message (max retries: 60)

    Avail->>Handler: process(message)
    Handler->>DB: getByVin(vin)
    DB-->>Handler: Vehicle

    alt Vehicle not found
        Handler-->>Avail: Success (no retry needed)
    else Vehicle found
        Handler->>Handler: Check message freshness:<br/>message.enqueuedTime > vehicle.enqueuedTime?
        alt Stale message (out of order)
            Handler-->>Avail: Acknowledge (skip stale)
        else Fresh message
            Handler->>DB: upsertPurchasePending(vin, pending, enqueuedTime)
            Handler-->>Avail: Success
        end
    end

    Avail->>SB: Acknowledge message
</pre>
</div>

<h3 id="search-flow-diagram">Search Query Flow</h3>

<p>When a user searches for vehicles on Driveway.com, the frontend sends a GraphQL query to the
<code>search</code> module. Here's how a search request flows through the system:</p>

<div class="mermaid-container reveal">
<div class="mermaid-label">Search Request Processing</div>
<pre class="mermaid">
sequenceDiagram
    participant User as Driveway.com Frontend
    participant GQL as odyssey-search-graphql
    participant Builder as PipelineBuilder
    participant Atlas as MongoDB Atlas Search
    participant DB as MongoDB vehicleV3
    participant Max as MaxDigital API

    User->>GQL: GraphQL query: search(filters, sort, pagination)
    GQL->>Builder: Build aggregation pipeline
    Builder->>Builder: 1. SearchBlock (Atlas Search stage)<br/>2. CompoundBlock (must/should/mustNot)<br/>3. TextBlock, RangeBlock, NearBlock<br/>4. Score weights from searchScoreWeights

    Builder-->>GQL: Pipeline&lt;Vehicle&gt;

    GQL->>Atlas: Run aggregation pipeline<br/>(shopSearch index, 50+ fields)
    Atlas-->>GQL: Scored + filtered vehicles

    GQL->>GQL: Apply post-search transforms:<br/>shipping fee calculation,<br/>sort field projection

    GQL-->>User: SearchResult { vehicles, totalCount, facets }

    Note over User,Max: Image queries are separate
    User->>GQL: getVehicleImagesById(id)
    GQL->>Max: GraphQL: GetGalleryImages
    Max-->>GQL: 6 image sizes per photo
    GQL-->>User: ImageGallery
</pre>
</div>

<hr>

<!-- ==================== TECH STACK ==================== -->
<h2 id="tech-stack" class="reveal">Technology Stack</h2>

<table>
    <tr><th>Technology</th><th>Version</th><th>JS Equivalent</th><th>Purpose</th></tr>
    <tr><td>Kotlin</td><td>1.9.20</td><td>TypeScript</td><td>Language (compiles to JVM bytecode)</td></tr>
    <tr><td>JDK</td><td>21 (Temurin)</td><td>Node.js runtime</td><td>Runtime environment</td></tr>
    <tr><td>Gradle</td><td>8.5 (Kotlin DSL)</td><td>npm/yarn</td><td>Build tool &amp; dependency management</td></tr>
    <tr><td>Spring Boot</td><td>3.4.3</td><td>Express/Fastify</td><td>Web framework with DI container</td></tr>
    <tr><td>Spring WebFlux</td><td>6.2.3</td><td>-</td><td>Reactive HTTP server (non-blocking)</td></tr>
    <tr><td>Project Reactor</td><td>3.5+</td><td>RxJS</td><td>Reactive programming library</td></tr>
    <tr><td>KMongo</td><td>4.7.1</td><td>Mongoose</td><td>MongoDB driver for Kotlin</td></tr>
    <tr><td>GraphQL Kotlin</td><td>7.0.2</td><td>Apollo Server</td><td>Code-first GraphQL server</td></tr>
    <tr><td>Azure Service Bus</td><td>7.10.1</td><td>@azure/service-bus</td><td>Message queue/pub-sub</td></tr>
    <tr><td>MockK</td><td>1.13.4</td><td>Jest mocks</td><td>Mocking framework for tests</td></tr>
    <tr><td>BlockHound</td><td>1.0.11</td><td>-</td><td>Detects blocking calls in reactive code</td></tr>
    <tr><td>Kotlinx Coroutines</td><td>1.7.3</td><td>async/await</td><td>Structured concurrency</td></tr>
</table>

<hr>

<!-- ==================== PROJECT REACTOR ==================== -->
<h2 id="reactor-intro" class="reveal">Project Reactor: The Reactive Foundation</h2>

<p>
    <strong>Project Reactor is the single most important technology to understand in this codebase.</strong>
    It's used everywhere &mdash; DAOs, services, controllers, cron jobs, message handlers.
    If you understand Reactor, you understand how data flows through the entire system.
</p>

<h3>Why Reactive?</h3>
<p>
    In traditional (blocking) code, when you make a database query, the thread <em>waits</em> until the result comes back.
    With 100 concurrent requests, you need 100 threads. Reactive programming flips this: instead of threads waiting,
    you describe <em>what to do when data arrives</em> using callbacks organized into a pipeline. A single thread can
    handle many requests because it never blocks.
</p>

<div class="callout callout-info reveal">
    <div class="callout-title">JavaScript Analogy</div>
    <p>
        Think of it like this:<br>
        <code>Mono&lt;T&gt;</code> = <code>Promise&lt;T&gt;</code> &mdash; will emit 0 or 1 value, then complete<br>
        <code>Flux&lt;T&gt;</code> = <code>Observable&lt;T&gt;</code> (RxJS) &mdash; will emit 0 to N values, then complete<br><br>
        Just like Promises, <strong>nothing happens until you subscribe</strong> (similar to how an Observable is "cold" until subscribed to).
    </p>
</div>

<!-- MONO VS FLUX -->
<h3 id="mono-flux" class="reveal">Mono vs Flux: The Two Core Types</h3>

<h4>Mono&lt;T&gt; &mdash; A Promise for a single value</h4>
<p>A <code>Mono&lt;T&gt;</code> represents a computation that will produce <strong>at most one result</strong>.
It can complete with a value, complete empty (like <code>null</code>), or complete with an error.</p>

<pre><code><span class="cmt">// JavaScript equivalent:</span>
<span class="cmt">// const getUser = async (id) =&gt; await db.findOne({ id })</span>
<span class="cmt">// Returns Promise&lt;User | null&gt;</span>

<span class="cmt">// Kotlin/Reactor equivalent:</span>
<span class="kw">fun</span> <span class="fn">getByVin</span>(vin: <span class="type">String</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt; =
    mongoCollection
        .find(<span class="type">Vehicle</span>::vin eq vin)   <span class="cmt">// Build a MongoDB query</span>
        .toReactor()                    <span class="cmt">// Convert MongoDB publisher to Reactor type</span>
        .first()                        <span class="cmt">// Take only the first result → Mono&lt;Vehicle&gt;</span>
</code></pre>

<h4>Flux&lt;T&gt; &mdash; An Observable stream of values</h4>
<p>A <code>Flux&lt;T&gt;</code> represents a stream of <strong>0 to N values</strong>.
It's like an RxJS Observable or a Node.js ReadableStream.</p>

<pre><code><span class="cmt">// JavaScript equivalent:</span>
<span class="cmt">// const getAll = () =&gt; db.find({ condition: 'NEW' }).stream()</span>

<span class="cmt">// Kotlin/Reactor equivalent:</span>
<span class="kw">fun</span> <span class="fn">getNewVehicles</span>(): <span class="type">Flux</span>&lt;<span class="type">Vehicle</span>&gt; =
    mongoCollection
        .find(<span class="type">Vehicle</span>::vehicleCondition eq <span class="type">VehicleCondition</span>.NEW)
        .toReactor()                    <span class="cmt">// Returns Flux&lt;Vehicle&gt; (a stream of all new vehicles)</span>
</code></pre>

<h4>Key differences from Promises</h4>
<table>
    <tr><th>Concept</th><th>JavaScript Promise</th><th>Reactor Mono/Flux</th></tr>
    <tr><td>Eagerness</td><td>Promise starts immediately</td><td><strong>Cold</strong>: nothing happens until <code>.subscribe()</code></td></tr>
    <tr><td>Retry</td><td>Manual retry logic</td><td>Built-in: <code>.retry(3)</code>, <code>.retryWhen(Retry.backoff(...))</code></td></tr>
    <tr><td>Cancellation</td><td>AbortController</td><td>Built-in via Disposable</td></tr>
    <tr><td>Backpressure</td><td>Not supported</td><td>Built-in: subscriber controls demand</td></tr>
    <tr><td>Multiple values</td><td>Need AsyncIterator</td><td>Flux naturally emits many values</td></tr>
    <tr><td>Error handling</td><td><code>.catch()</code></td><td><code>.onErrorResume()</code>, <code>.onErrorMap()</code>, <code>.onErrorReturn()</code></td></tr>
</table>

<!-- INTERACTIVE: Mono Lifecycle Visualizer -->
<div class="lifecycle-demo reveal" id="monoLifecycle">
    <h4 style="margin-top:0"><span class="section-number">!</span> Interactive: Mono Lifecycle</h4>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:4px;">
        Watch how a <code>Mono&lt;Vehicle&gt;</code> signal flows. Click a scenario to see it animate:
    </p>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px;">
        <button class="demo-btn" onclick="runMonoLifecycle('success')" style="font-size:12px;padding:8px 16px;">Success Path</button>
        <button class="demo-btn" onclick="runMonoLifecycle('empty')" style="font-size:12px;padding:8px 16px;background:linear-gradient(135deg, var(--accent-orange), var(--accent-red));">Empty Path</button>
        <button class="demo-btn" onclick="runMonoLifecycle('error')" style="font-size:12px;padding:8px 16px;background:linear-gradient(135deg, var(--accent-red), #d63384);">Error Path</button>
    </div>
    <div class="lifecycle-track" id="monoTrack">
        <div class="lifecycle-node">
            <div class="lifecycle-circle" id="lc-subscribe">S</div>
            <div class="lifecycle-label" id="lc-subscribe-label">.subscribe()</div>
        </div>
        <div class="lifecycle-line" id="lc-line1"><div class="lifecycle-data-particle" id="lc-particle1"></div></div>
        <div class="lifecycle-node">
            <div class="lifecycle-circle" id="lc-onnext">?</div>
            <div class="lifecycle-label" id="lc-onnext-label">onNext / onError</div>
        </div>
        <div class="lifecycle-line" id="lc-line2"><div class="lifecycle-data-particle" id="lc-particle2"></div></div>
        <div class="lifecycle-node">
            <div class="lifecycle-circle" id="lc-complete">C</div>
            <div class="lifecycle-label" id="lc-complete-label">onComplete</div>
        </div>
    </div>
    <div class="demo-explanation" id="monoExplanation">Click a button above to see how data flows through a Mono in each scenario.</div>
</div>

<!-- INTERACTIVE: Blocking vs Non-Blocking Comparison -->
<div class="reveal" style="margin:28px 0;">
    <h4><span class="section-number">!</span> Visual: Blocking vs Non-Blocking</h4>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:8px;">
        See why reactive matters. Both examples handle 3 database queries:
    </p>
    <div class="comparison-container" id="blockingComparison">
        <div class="comparison-panel blocking">
            <h5>Blocking (Traditional)</h5>
            <p style="font-size:11px;color:var(--text-muted);margin-bottom:10px;">Each thread waits idle while DB responds</p>
            <div class="thread-lane">
                <span class="thread-label">Thread 1</span>
                <div class="thread-segment work visible" style="width:20%">query</div>
                <div class="thread-segment wait visible" style="width:40%">waiting...</div>
                <div class="thread-segment work visible" style="width:15%">process</div>
                <div class="thread-segment idle visible" style="width:25%"></div>
            </div>
            <div class="thread-lane">
                <span class="thread-label">Thread 2</span>
                <div class="thread-segment work visible" style="width:20%">query</div>
                <div class="thread-segment wait visible" style="width:40%">waiting...</div>
                <div class="thread-segment work visible" style="width:15%">process</div>
                <div class="thread-segment idle visible" style="width:25%"></div>
            </div>
            <div class="thread-lane">
                <span class="thread-label">Thread 3</span>
                <div class="thread-segment work visible" style="width:20%">query</div>
                <div class="thread-segment wait visible" style="width:40%">waiting...</div>
                <div class="thread-segment work visible" style="width:15%">process</div>
                <div class="thread-segment idle visible" style="width:25%"></div>
            </div>
            <p style="font-size:11px;color:var(--accent-red);margin-top:10px;margin-bottom:0;">3 threads used. Each idle ~40% of time.</p>
        </div>
        <div class="comparison-panel nonblocking">
            <h5>Non-Blocking (Reactor)</h5>
            <p style="font-size:11px;color:var(--text-muted);margin-bottom:10px;">One thread handles all 3 queries concurrently</p>
            <div class="thread-lane">
                <span class="thread-label">Thread 1</span>
                <div class="thread-segment work-green visible" style="width:18%">q1</div>
                <div class="thread-segment work-green visible" style="width:18%">q2</div>
                <div class="thread-segment work-green visible" style="width:18%">q3</div>
                <div class="thread-segment work-green visible" style="width:14%">p1</div>
                <div class="thread-segment work-green visible" style="width:14%">p2</div>
                <div class="thread-segment work-green visible" style="width:14%">p3</div>
            </div>
            <div class="thread-lane">
                <span class="thread-label">Thread 2</span>
                <div class="thread-segment idle visible" style="width:100%"></div>
            </div>
            <div class="thread-lane">
                <span class="thread-label">Thread 3</span>
                <div class="thread-segment idle visible" style="width:100%"></div>
            </div>
            <p style="font-size:11px;color:var(--accent-green);margin-top:10px;margin-bottom:0;">1 thread. Zero idle time. Same throughput.</p>
        </div>
    </div>
</div>

<div class="key-takeaway reveal">
    <p><strong>Reactor is the Promise system of Kotlin/Spring.</strong> If you understand <code>Promise.then()</code> in JS,
    you already understand <code>Mono.flatMap()</code>. The core difference: Reactor streams are <strong>lazy</strong> (nothing runs until
    <code>.subscribe()</code>) and support <strong>backpressure</strong> (the consumer controls how fast data arrives).</p>
</div>

<!-- REACTIVE CHAINS -->
<h3 id="reactive-chains" class="reveal">Building Reactive Chains</h3>

<p>In Reactor, you compose operations by chaining operators. Each operator transforms the stream without blocking.
Here's how the real code in Odyssey builds reactive chains:</p>

<h4>Example 1: Simple find-and-update (from MongoVehicleDaoImpl.kt)</h4>
<pre><code><span class="cmt">// This is like: findOne(vin).then(vehicle =&gt; updateField(vehicle))</span>

<span class="kw">override fun</span> <span class="fn">updateManuallySuppressed</span>(vin: <span class="type">String</span>, suppress: <span class="type">Boolean</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt; {
    <span class="kw">return</span> mongoCollection.findOneById(vin)         <span class="cmt">// Step 1: Find vehicle (Mono&lt;Vehicle&gt;)</span>
        .flatMap {                                     <span class="cmt">// Step 2: When found, update it</span>
            updateVehicleField(it.vin, <span class="type">Vehicle</span>::manuallySuppressed, suppress)
                .doOnNext { log.info(<span class="str">"Completed upsert"</span>) }   <span class="cmt">// Side effect: log</span>
                .onErrorMap { e -&gt;                     <span class="cmt">// Step 3: Transform errors</span>
                    Exception(<span class="str">"Failed for vin $vin"</span>, e)
                }
        }
}
</code></pre>

<div class="callout callout-warn reveal">
    <div class="callout-title">.map() vs .flatMap() &mdash; The most important distinction</div>
    <p>
        <code>.map()</code> transforms the value synchronously (like <code>Array.map()</code>).<br>
        <code>.flatMap()</code> transforms the value into <em>another</em> Mono/Flux and "flattens" it (like <code>.then()</code> in Promises).<br><br>
        <strong>Rule of thumb:</strong> If your transformation returns a <code>Mono</code> or <code>Flux</code>, use <code>flatMap</code>.
        If it returns a plain value, use <code>map</code>.
    </p>
</div>

<h4>Example 2: Complex chain with buffering (from CronLeasing.kt)</h4>
<pre><code><span class="cmt">// This processes ALL leasable vehicles in batches, filters expired ones,</span>
<span class="cmt">// transforms them, and upserts the results back to MongoDB.</span>
<span class="cmt">// In JS terms: readable stream -&gt; transform -&gt; batch -&gt; write</span>

<span class="kw">fun</span> <span class="fn">applyLeaseExpiries</span>(): <span class="type">Mono</span>&lt;<span class="type">Long</span>&gt; =
    vehicleDao
        .getLeasableVehicles()                        <span class="cmt">// Flux&lt;Vehicle&gt; - stream of ALL leasable vehicles</span>
        .buffer(<span class="num">100</span>)                                  <span class="cmt">// Collect into batches of 100</span>
        .flatMapIterable { it }                       <span class="cmt">// Flatten batches back to individual items</span>
        .transformDeferred { transformLeasingFlow(it, <span class="type">Instant</span>.now()) }
                                                      <span class="cmt">// Apply our business logic transformation</span>
        .buffer(<span class="num">100</span>)                                  <span class="cmt">// Re-batch for bulk write</span>
        .doOnNext { log.info(<span class="str">"Upserting batch of ${it.size}"</span>) }
                                                      <span class="cmt">// Side-effect: log progress</span>
        .flatMap { updatedVehicles -&gt;                  <span class="cmt">// For each batch, write to DB</span>
            vehicleDao.upsertVehicles(updatedVehicles)
        }
        .count()                                      <span class="cmt">// Count total processed (Flux → Mono&lt;Long&gt;)</span>
        .doOnNext { log.info(<span class="str">"$it vehicles updated"</span>) }
        .checkpoint(<span class="str">"Lease expiry check"</span>)              <span class="cmt">// Named checkpoint for debugging</span>
        .doOnSubscribe { log.info(<span class="str">"Starting..."</span>) }    <span class="cmt">// Runs when someone subscribes</span>
        .doOnSuccess { log.info(<span class="str">"Complete."</span>) }         <span class="cmt">// Runs on successful completion</span>
</code></pre>

<!-- REACTOR OPERATORS -->
<h3 id="reactor-operators" class="reveal">Key Operators Used in Odyssey</h3>

<p>Here is every major Reactor operator used in this codebase, with what it does and its JavaScript equivalent:</p>

<table>
    <tr><th>Operator</th><th>Type</th><th>What it Does</th><th>JS Equivalent</th></tr>
    <tr><td><code>.map(fn)</code></td><td>Transform</td><td>Synchronously transform the value</td><td><code>.then(x =&gt; transform(x))</code></td></tr>
    <tr><td><code>.flatMap(fn)</code></td><td>Transform</td><td>Async transform, returns Mono/Flux</td><td><code>.then(x =&gt; asyncOp(x))</code></td></tr>
    <tr><td><code>.filter(predicate)</code></td><td>Filter</td><td>Keep only matching items</td><td><code>.filter()</code></td></tr>
    <tr><td><code>.then(mono)</code></td><td>Sequence</td><td>Ignore result, chain next operation</td><td><code>.then(() =&gt; nextOp())</code></td></tr>
    <tr><td><code>.thenReturn(val)</code></td><td>Sequence</td><td>Ignore result, return fixed value</td><td><code>.then(() =&gt; val)</code></td></tr>
    <tr><td><code>.switchIfEmpty(alt)</code></td><td>Fallback</td><td>Provide alternative if stream is empty</td><td><code>?? defaultValue</code></td></tr>
    <tr><td><code>.onErrorResume(fn)</code></td><td>Error</td><td>Recover from error with new Mono/Flux</td><td><code>.catch(e =&gt; fallback)</code></td></tr>
    <tr><td><code>.onErrorMap(fn)</code></td><td>Error</td><td>Transform the error type</td><td><code>.catch(e =&gt; { throw new E(e) })</code></td></tr>
    <tr><td><code>.doOnNext(fn)</code></td><td>Side-effect</td><td>Peek at values (logging, metrics)</td><td><code>.then(x =&gt; { log(x); return x })</code></td></tr>
    <tr><td><code>.doOnError(fn)</code></td><td>Side-effect</td><td>Peek at errors (logging)</td><td><code>.catch(e =&gt; { log(e); throw e })</code></td></tr>
    <tr><td><code>.doOnSubscribe(fn)</code></td><td>Side-effect</td><td>Run when subscription starts</td><td>No direct equivalent</td></tr>
    <tr><td><code>.doFinally(fn)</code></td><td>Side-effect</td><td>Run after completion/error/cancel</td><td><code>.finally()</code></td></tr>
    <tr><td><code>.buffer(n)</code></td><td>Batch</td><td>Collect n items into a List</td><td>Manual chunking</td></tr>
    <tr><td><code>.limitRate(n)</code></td><td>Backpressure</td><td>Request items n at a time</td><td>No direct equivalent</td></tr>
    <tr><td><code>.collectList()</code></td><td>Aggregate</td><td>Collect all Flux items into Mono&lt;List&gt;</td><td><code>Promise.all()</code></td></tr>
    <tr><td><code>.count()</code></td><td>Aggregate</td><td>Count all items (Flux &rarr; Mono&lt;Long&gt;)</td><td><code>.length</code></td></tr>
    <tr><td><code>.retryWhen(spec)</code></td><td>Resilience</td><td>Retry with backoff strategy</td><td>Manual retry with setTimeout</td></tr>
    <tr><td><code>.checkpoint(name)</code></td><td>Debug</td><td>Add named checkpoint to stack traces</td><td>No equivalent</td></tr>
    <tr><td><code>.subscribeOn(sched)</code></td><td>Threading</td><td>Choose which thread pool to run on</td><td>No equivalent (single-threaded)</td></tr>
    <tr><td><code>.block()</code></td><td>Blocking!</td><td>Wait for result (blocks the thread)</td><td><code>await</code></td></tr>
    <tr><td><code>Mono.defer { }</code></td><td>Creation</td><td>Lazily create a Mono (re-evaluated per subscriber)</td><td><code>() =&gt; new Promise()</code></td></tr>
    <tr><td><code>Mono.just(val)</code></td><td>Creation</td><td>Wrap a value in a Mono</td><td><code>Promise.resolve(val)</code></td></tr>
    <tr><td><code>Mono.empty()</code></td><td>Creation</td><td>A Mono that completes without a value</td><td><code>Promise.resolve(undefined)</code></td></tr>
    <tr><td><code>Mono.error(e)</code></td><td>Creation</td><td>A Mono that immediately errors</td><td><code>Promise.reject(e)</code></td></tr>
</table>

<!-- INTERACTIVE: Reactive Operator Pipeline Demo -->
<div class="pipeline-demo reveal" id="pipelineDemo">
    <h4><span class="section-number">!</span> Interactive: Reactive Operator Pipeline</h4>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:4px;">
        Watch data flow through a chain of Reactor operators, just like in the Odyssey codebase.
        This simulates: <code>Flux.just(1..6).filter(x > 2).map(x * 10).take(3)</code>
    </p>
    <div class="pipeline-stages" id="pipeStages">
        <div class="pipeline-stage" id="ps-source">Flux.just()</div>
        <span class="pipeline-arrow" id="pa-1">&rarr;</span>
        <div class="pipeline-stage" id="ps-filter">.filter()</div>
        <span class="pipeline-arrow" id="pa-2">&rarr;</span>
        <div class="pipeline-stage" id="ps-map">.map()</div>
        <span class="pipeline-arrow" id="pa-3">&rarr;</span>
        <div class="pipeline-stage" id="ps-take">.take(3)</div>
        <span class="pipeline-arrow" id="pa-4">&rarr;</span>
        <div class="pipeline-stage" id="ps-subscribe">subscriber</div>
    </div>
    <div>
        <div class="demo-label">Input</div>
        <div class="data-track" id="dt-input"></div>
    </div>
    <div>
        <div class="demo-label">After .filter(x &gt; 2)</div>
        <div class="data-track" id="dt-filter"></div>
    </div>
    <div>
        <div class="demo-label">After .map(x * 10)</div>
        <div class="data-track" id="dt-map"></div>
    </div>
    <div>
        <div class="demo-label">After .take(3)</div>
        <div class="data-track" id="dt-take"></div>
    </div>
    <button class="demo-btn" id="runPipeline" onclick="runReactivePipeline()">Run Pipeline</button>
    <div class="demo-explanation" id="pipeExplanation">Click "Run Pipeline" to watch data items flow through each operator in sequence.</div>
</div>

<!-- REACTIVE DAO -->
<h3 id="reactive-dao" class="reveal">Reactive DAOs in Practice</h3>

<p>Every database operation in Odyssey returns a <code>Mono</code> or <code>Flux</code>. Here's the <code>VehicleDao</code>
interface &mdash; notice every method signature:</p>

<pre><code><span class="kw">interface</span> <span class="type">VehicleDao</span> : <span class="type">MongoAggregationDao</span>&lt;<span class="type">Vehicle</span>&gt; {
    <span class="kw">fun</span> <span class="fn">upsertVehicle</span>(vehicle: <span class="type">Vehicle</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt;          <span class="cmt">// Insert or update one vehicle</span>
    <span class="kw">fun</span> <span class="fn">upsertVehicles</span>(vehicles: <span class="type">List</span>&lt;<span class="type">Vehicle</span>&gt;): <span class="type">Flux</span>&lt;<span class="type">Vehicle</span>&gt;   <span class="cmt">// Bulk upsert</span>
    <span class="kw">fun</span> <span class="fn">getByVin</span>(vin: <span class="type">String</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt;                    <span class="cmt">// Find by VIN (primary key)</span>
    <span class="kw">fun</span> <span class="fn">getById</span>(id: <span class="type">String</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt;                     <span class="cmt">// Find by vehicleId</span>
    <span class="kw">fun</span> <span class="fn">getLeasableVehicles</span>(): <span class="type">Flux</span>&lt;<span class="type">Vehicle</span>&gt;                     <span class="cmt">// Stream of all leasable vehicles</span>
    <span class="kw">fun</span> <span class="fn">vinExists</span>(vin: <span class="type">String</span>): <span class="type">Mono</span>&lt;<span class="type">Boolean</span>&gt;                   <span class="cmt">// Check existence</span>
    <span class="kw">fun</span> <span class="fn">cleanUpDeletedRecords</span>(): <span class="type">Mono</span>&lt;<span class="type">DeleteResult</span>&gt;              <span class="cmt">// Delete all DELETED status</span>
    <span class="kw">fun</span> <span class="fn">markMissingRowsDeleted</span>(job: <span class="type">InventoryJobDetails</span>): <span class="type">Mono</span>&lt;<span class="type">UpdateResult</span>&gt;
    <span class="cmt">// ... and more</span>
}
</code></pre>

<p>And here are key implementations from <code>MongoVehicleDaoImpl.kt</code>:</p>

<pre><code><span class="cmt">// Simple upsert - save returns a Mono that completes when the write is done</span>
<span class="kw">override fun</span> <span class="fn">upsertVehicle</span>(vehicle: <span class="type">Vehicle</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt; =
    mongoCollection.save(vehicle).thenReturn(vehicle)

<span class="cmt">// Check if a VIN exists - uses switchIfEmpty for the "not found" case</span>
<span class="kw">override fun</span> <span class="fn">vinExists</span>(vin: <span class="type">String</span>): <span class="type">Mono</span>&lt;<span class="type">Boolean</span>&gt; =
    mongoCollection
        .find(<span class="type">Vehicle</span>::vin eq vin)              <span class="cmt">// Query MongoDB</span>
        .projection(<span class="type">Document</span>(<span class="type">Vehicle</span>::vin.path(), <span class="num">1</span>))  <span class="cmt">// Only fetch the VIN field</span>
        .first()                                  <span class="cmt">// Get first result</span>
        .toMono()                                  <span class="cmt">// Convert to Reactor Mono</span>
        .map { <span class="kw">true</span> }                              <span class="cmt">// Found it → true</span>
        .switchIfEmpty { <span class="type">Mono</span>.just(<span class="kw">false</span>) }       <span class="cmt">// Not found → false</span>

<span class="cmt">// Bulk upsert with BulkWrite - notice the empty list guard</span>
<span class="kw">override fun</span> <span class="fn">upsertVehicles</span>(vehicles: <span class="type">List</span>&lt;<span class="type">Vehicle</span>&gt;): <span class="type">Flux</span>&lt;<span class="type">Vehicle</span>&gt; =
    <span class="kw">if</span> (vehicles.isEmpty()) {
        <span class="type">Flux</span>.empty()                              <span class="cmt">// MongoDB complains on empty bulk write</span>
    } <span class="kw">else</span> {
        mongoCollection.bulkWrite(
            vehicles.map { replaceOne(<span class="type">Vehicle</span>::vin eq it.vin, it, replaceUpsert()) },
            <span class="type">BulkWriteOptions</span>().ordered(<span class="kw">false</span>)       <span class="cmt">// Unordered = parallel writes</span>
        ).toMono().flatMapMany { vehicles.toFlux() }
    }

<span class="cmt">// Update with complex nested field path - uses KMongo's / operator</span>
<span class="kw">override fun</span> <span class="fn">upsertPurchasePending</span>(vin: <span class="type">String</span>, suppress: <span class="type">Boolean</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt; {
    <span class="kw">return</span> mongoCollection.findOneById(vin)
        .switchIfEmpty { <span class="type">Mono</span>.error(<span class="type">NoSuchElementException</span>(<span class="str">"VIN $vin not found."</span>)) }
        .flatMap {
            <span class="cmt">// Vehicle::availability / Availability::purchasePending</span>
            <span class="cmt">// This creates the MongoDB path "availability.purchasePending"</span>
            updateVehicleField(it.vin, <span class="type">Vehicle</span>::availability / <span class="type">Availability</span>::purchasePending, suppress)
        }
        .doFinally { signal -&gt;
            <span class="kw">when</span> (signal) {
                <span class="type">SignalType</span>.ON_COMPLETE -&gt; log.info(<span class="str">"Completed"</span>)
                <span class="type">SignalType</span>.ON_ERROR -&gt; log.error(<span class="str">"Error"</span>)
                <span class="kw">else</span> -&gt; log.warn(<span class="str">"Unexpected signal: ${signal.name}"</span>)
            }
        }
}
</code></pre>

<!-- REACTIVE ERROR HANDLING -->
<h3 id="reactive-error" class="reveal">Error Handling in Reactor</h3>

<p>Error handling in Reactor is fundamentally different from try/catch. Errors propagate
through the reactive chain as <em>signals</em>, not thrown exceptions:</p>

<pre><code><span class="cmt">// PATTERN 1: onErrorResume - Recover from error with alternative value</span>
<span class="cmt">// JS: .catch(e =&gt; fallbackValue)</span>
postalCodeOemRegionsDao.upsertRegions(regions)
    .collectList()
    .onErrorResume {
        log.error(<span class="str">"Failed to upsert regions"</span>, it)
        <span class="type">Mono</span>.empty()   <span class="cmt">// Swallow the error, return empty</span>
    }

<span class="cmt">// PATTERN 2: onErrorMap - Transform error to a different type</span>
<span class="cmt">// JS: .catch(e =&gt; { throw new CustomError(e) })</span>
cronDeleteCheck.checkForLargeDelete(tempImport, vehicleDao)
    .onErrorMap(<span class="type">CronDeleteCheck</span>.<span class="type">DeleteCheckFailureException</span>::<span class="kw">class</span>.java) { e -&gt;
        <span class="type">JobException</span>(jobDetails, <span class="type">JobStatus</span>.SUSPICIOUS_FILE, e.message!!)
    }

<span class="cmt">// PATTERN 3: switchIfEmpty - Handle "not found" without exceptions</span>
<span class="cmt">// JS: result ?? throwNew404()</span>
mongoCollection.findOneById(vin)
    .switchIfEmpty { <span class="type">Mono</span>.error(<span class="type">NoSuchElementException</span>(<span class="str">"VIN not found"</span>)) }

<span class="cmt">// PATTERN 4: doOnError - Log errors without consuming them</span>
<span class="cmt">// JS: .catch(e =&gt; { console.error(e); throw e })</span>
vehicleDao.upsertVehicle(vehicle)
    .doOnError { log.error(<span class="str">"Failed to upsert: ${it.message}"</span>) }
</code></pre>

<!-- BLOCKHOUND -->
<h3 id="blockhound" class="reveal">BlockHound: The Blocking Call Detector</h3>

<p>
    <strong>BlockHound</strong> is a Java agent that monitors threads at runtime and <em>throws an exception</em>
    if any blocking call is made on a non-blocking thread. This is critical because one accidental
    <code>Thread.sleep()</code> or synchronous file read on a Reactor event-loop thread can stall
    the entire server.
</p>

<div class="callout callout-danger reveal">
    <div class="callout-title">The Golden Rule of Reactive: NEVER BLOCK</div>
    <p>
        In a reactive application, blocking calls on event-loop threads are catastrophic.
        Unlike Node.js (which has a single event loop), Reactor uses a small pool of event-loop threads.
        If you block one, you lose a significant percentage of your throughput.
        BlockHound catches these mistakes before they reach production.
    </p>
</div>

<p>Here's how BlockHound is configured in Odyssey (from <code>BlockhoundStartup.kt</code>):</p>

<pre><code><span class="ann">@Component</span>
<span class="kw">class</span> <span class="type">BlockhoundStartup</span>(
    <span class="kw">val</span> config: <span class="type">BlockhoundConfig</span>  <span class="cmt">// blockhound.enabled from application.yml</span>
) {
    <span class="ann">@PostConstruct</span>
    <span class="kw">fun</span> <span class="fn">initialize</span>() {
        <span class="kw">if</span> (config.enabled) {
            <span class="kw">val</span> builder = <span class="type">BlockHound</span>.builder()

            <span class="cmt">// Load all registered integrations (Spring, Netty, etc.)</span>
            <span class="kw">val</span> serviceLoader = <span class="type">ServiceLoader</span>.load(<span class="type">BlockHoundIntegration</span>::<span class="kw">class</span>.java)
            <span class="type">StreamSupport</span>.stream(serviceLoader.spliterator(), <span class="kw">false</span>)
                .sorted()
                .forEach { builder.with(it) }

            <span class="cmt">// Allow known-safe blocking calls</span>
            builder.allowBlockingCallsInside(<span class="str">"java.security.SecureRandom"</span>, <span class="str">"nextBytes"</span>)
            builder.allowBlockingCallsInside(<span class="str">"java.util.jar.JarFile"</span>, <span class="str">"getEntry"</span>)

            builder.install()
        }
    }
}
</code></pre>

<p>BlockHound is <strong>disabled in laptop and UAT profiles</strong> and can be toggled via
<code>blockhound.enabled: true/false</code> in the YAML config.</p>

<!-- COROUTINES + REACTOR -->
<h3 id="coroutines-reactor" class="reveal">Coroutines + Reactor Bridge</h3>

<p>Odyssey uses <strong>Kotlin Coroutines alongside Reactor</strong>. Coroutines give you <code>async/await</code> syntax,
while Reactor provides the reactive stream infrastructure. They bridge together with a few key functions:</p>

<pre><code><span class="cmt">// BRIDGE 1: mono { } - Create a Mono from a coroutine</span>
<span class="cmt">// Like wrapping async code in a Promise</span>
<span class="kw">fun</span> <span class="fn">doVehicleImport</span>(jobDetails: <span class="type">InventoryJobDetails</span>): <span class="type">Mono</span>&lt;<span class="type">InventoryJobDetails</span>&gt; =
    <span class="fn">mono</span> { coDoVehicleImport(jobDetails) }   <span class="cmt">// Coroutine → Mono</span>

<span class="cmt">// BRIDGE 2: .awaitFirst() / .awaitSingleOrNull() - Suspend on a Mono/Flux</span>
<span class="cmt">// Like 'await' in JavaScript</span>
<span class="kw">suspend fun</span> <span class="fn">coDoVehicleImport</span>(jobDetails: <span class="type">InventoryJobDetails</span>): <span class="type">InventoryJobDetails</span> {
    <span class="kw">val</span> result = tempImport
        .addVehicles(chunk)
        .collectList()
        .awaitFirst()        <span class="cmt">// Suspend until the Mono completes (like await)</span>
    <span class="kw">return</span> result
}

<span class="cmt">// BRIDGE 3: Semaphore for concurrency control</span>
<span class="cmt">// Like p-limit or p-queue in Node.js</span>
<span class="kw">val</span> csvSemaphore = <span class="type">Semaphore</span>(permits = <span class="num">5</span>)   <span class="cmt">// Max 5 concurrent operations</span>

rows.chunked(<span class="num">500</span>).map { chunk -&gt;
    async {                                   <span class="cmt">// Launch concurrent coroutine</span>
        csvSemaphore.withPermit {             <span class="cmt">// But limit concurrency to 5</span>
            tempImport.addVehicles(chunk)
                .collectList()
                .awaitFirst()
        }
    }
}.awaitAll()                                  <span class="cmt">// Wait for all chunks (like Promise.all)</span>
</code></pre>

<hr>

<!-- ==================== CRON JOBS ==================== -->
<h2 id="cron-overview" class="reveal">Cron Jobs: The Data Engine</h2>

<p>The <code>cron</code> module is the data engine that keeps Odyssey alive. It runs 5 scheduled jobs
that import vehicle inventory, synchronize pricing data, clean up stale records, and report metrics.
Without the cron module, the vehicle data would become stale within hours.</p>

<table>
    <tr><th>Job</th><th>Schedule</th><th>What It Does</th><th>Business Impact</th></tr>
    <tr>
        <td><span class="badge badge-cron">EDS Import</span></td>
        <td>Every 30 min<br><code>0 0,30 * * * *</code></td>
        <td>Imports vehicle inventory from Azure Blob TSV files</td>
        <td>Keeps 100K+ vehicle listings up to date</td>
    </tr>
    <tr>
        <td><span class="badge badge-cron">Region Sync</span></td>
        <td>4x daily<br><code>0 45 0,6,12,18 * * *</code></td>
        <td>Syncs OEM region &rarr; postal code mappings</td>
        <td>Enables regional leasing pricing</td>
    </tr>
    <tr>
        <td><span class="badge badge-cron">Stale Cleanup</span></td>
        <td>Hourly at :15<br><code>0 15 * * * *</code></td>
        <td>Deletes vehicles with status=DELETED</td>
        <td>Removes sold/delisted vehicles from search</td>
    </tr>
    <tr>
        <td><span class="badge badge-cron">Temp Cleanup</span></td>
        <td>Daily at 08:10<br><code>0 10 8 * * *</code></td>
        <td>Drops temp_ collections older than 28 days</td>
        <td>Prevents MongoDB storage bloat</td>
    </tr>
    <tr>
        <td><span class="badge badge-cron">Spin Metric</span></td>
        <td>Every 5 min<br><code>30 */5 * * * *</code></td>
        <td>Updates 360-degree photo count metric</td>
        <td>DataDog monitoring dashboard</td>
    </tr>
</table>

<div class="callout callout-warn reveal">
    <div class="callout-title">Laptop Profile: All Cron Jobs Disabled</div>
    <p>When running locally with <code>--spring.profiles.active=laptop</code>, all cron jobs are set to impossible dates
    (like "0 0 0 30 11 *" = Nov 30 at midnight, only runs once a year). This prevents them from firing during local development.</p>
</div>

<!-- SCHEDULED TASKS -->
<h3 id="cron-scheduler" class="reveal">ScheduledTasks: The Entry Point</h3>

<p>All cron jobs start in <code>ScheduledTasks.kt</code>. This is the Spring component that hooks into
Spring's <code>@Scheduled</code> annotation system:</p>

<pre><code><span class="ann">@Component</span>
<span class="kw">class</span> <span class="type">ScheduledTasks</span>(
    <span class="kw">private val</span> edsVehicleReaderV2: <span class="type">EdsVehicleReaderV2</span>,
    <span class="kw">private val</span> cronLeasing: <span class="type">CronLeasing</span>,
    <span class="kw">private val</span> postalCodeOemRegionSync: <span class="type">PostalCodeOemRegionSync</span>,
    <span class="kw">private val</span> cleanup: <span class="type">DatabaseCleanup</span>,
    <span class="kw">private val</span> metricUpdater: <span class="type">MetricUpdater</span>
) {
    <span class="cmt">// The main job: import vehicles + apply lease expiries</span>
    <span class="ann">@Scheduled</span>(cron = <span class="str">"\${cron.vehicleReader.cronTiming}"</span>)
    <span class="kw">fun</span> <span class="fn">runVehicleReaderImport</span>() {
        edsVehicleReaderV2
            .getReadVehiclesFlow()                       <span class="cmt">// Returns Mono&lt;InventoryJobDetails&gt;</span>
            .then(<span class="type">Mono</span>.defer { cronLeasing.applyLeaseExpiries() })  <span class="cmt">// Then apply lease expiries</span>
            .subscribeOn(<span class="type">Schedulers</span>.boundedElastic())       <span class="cmt">// Run on elastic thread pool</span>
            .block()                                     <span class="cmt">// Block: keep the @Scheduled thread alive</span>
    }
}
</code></pre>

<div class="callout callout-info reveal">
    <div class="callout-title">Why .block() here?</div>
    <p>Spring's <code>@Scheduled</code> methods must be synchronous &mdash; the framework expects the method to return when the work is done.
    Since our entire pipeline is reactive, we call <code>.block()</code> at the very top level to bridge from the synchronous
    scheduling world into the reactive world. This is one of the <strong>only</strong> places where <code>.block()</code> is acceptable.</p>
</div>

<!-- EDS IMPORT -->
<h3 id="cron-eds" class="reveal">EDS Vehicle Import Pipeline (The Big One)</h3>

<p>This is the most complex job in the system. It runs every 30 minutes and is responsible for importing
the entire vehicle inventory from <strong>EDS (Enterprise Data Services)</strong> TSV files stored in Azure Blob Storage.
The pipeline has 4 major stages:</p>

<div class="flow-diagram reveal"><span class="highlight">EDS Import Pipeline (every 30 minutes):</span>

  <span class="green">Stage 1: Job Management</span>
  ├── Check if another import is already running
  ├── If yes → abort with ALREADY_RUNNING status
  └── If no → create job record in inventoryJobDetails collection

  <span class="green">Stage 2: File Discovery</span>
  ├── List all files in Azure Blob container "inbound/CVP/Driveway-Merchandising-V2/"
  ├── Find the newest .csv.gz file (by timestamp in filename)
  ├── Check if this file was already processed (via blob metadata)
  └── Validate file is parseable

  <span class="green">Stage 3: Staged Import</span>
  ├── Create temporary collection: temp_vehicleV3_{timestamp}
  ├── Download and decompress GZIP TSV file
  ├── Parse each TSV row → EdsExtractedInventoryRow (76 fields)
  ├── Convert to Vehicle objects (enriching with categories, shipping, etc.)
  ├── Upload to temp collection in batches of 500 (5 concurrent semaphores)
  ├── <span class="red">SAFETY CHECK: Compare temp vs live collection counts</span>
  │   └── If delta > 15,000 vehicles → abort with SUSPICIOUS_FILE
  ├── Calculate inventory deltas (ADD/UPDATE/DELETE)
  ├── Publish deltas to inventory-delta-topic (Azure Service Bus)
  ├── Merge temp collection → live vehicleV3 (preserving leasing, suppression)
  └── Drop temp collection

  <span class="green">Stage 4: Post-Import</span>
  ├── Mark-and-sweep: vehicles not in this file → status=DELETED
  ├── Update search suggestions (autocomplete data)
  └── Record job completion in inventoryJobDetails</div>

<!-- INTERACTIVE: Animated EDS Pipeline -->
<div class="eds-pipeline reveal" id="edsPipeline">
    <h4 style="margin-top:0"><span class="section-number">!</span> Interactive: EDS Import Stage-by-Stage</h4>
    <p style="font-size:13px;color:var(--text-muted);margin-bottom:18px;">
        Click "Run Import" to watch each stage execute in sequence, just like the real pipeline:
    </p>

    <div class="eds-stage" id="eds-s1">
        <div class="stage-icon">1</div>
        <div class="stage-content">
            <h5>Job Management</h5>
            <p>Check if another import is running. If yes, abort. If no, create job record.</p>
        </div>
    </div>
    <div class="eds-connector" id="eds-c1"></div>

    <div class="eds-stage" id="eds-s2">
        <div class="stage-icon">2</div>
        <div class="stage-content">
            <h5>File Discovery</h5>
            <p>Find newest .csv.gz file in Azure Blob. Validate it starts with "full".</p>
        </div>
    </div>
    <div class="eds-connector" id="eds-c2"></div>

    <div class="eds-stage" id="eds-s3">
        <div class="stage-icon">3</div>
        <div class="stage-content">
            <h5>Staged Import</h5>
            <p>Create temp collection. Parse TSV. Upload in batches of 500 (5 concurrent). Safety check. Publish deltas. Merge to live.</p>
        </div>
    </div>
    <div class="eds-connector" id="eds-c3"></div>

    <div class="eds-stage" id="eds-s4">
        <div class="stage-icon">4</div>
        <div class="stage-content">
            <h5>Post-Import</h5>
            <p>Mark-and-sweep stale records. Update search suggestions. Record completion.</p>
        </div>
    </div>

    <div style="display:flex;align-items:center;gap:12px;margin-top:18px;">
        <button class="demo-btn" id="runEds" onclick="runEdsPipeline()">Run Import</button>
        <span id="edsStatus" style="font-size:12px;color:var(--text-muted);font-family:'JetBrains Mono',monospace;"></span>
    </div>
</div>

<h4 class="reveal">The Reactive Pipeline (EdsVehicleReaderV2.kt)</h4>

<p>Here's the actual reactive chain that orchestrates all 4 stages. Notice how each stage is chained using
<code>flatMap</code> and the custom <code>isStillRunning</code> infix function guards against executing stages
after a failure:</p>

<pre><code><span class="kw">fun</span> <span class="fn">getReadVehiclesFlow</span>(): <span class="type">Mono</span>&lt;<span class="type">InventoryJobDetails</span>&gt; {
    <span class="kw">val</span> initialJobDetails = cronJobTracker.createInitialJobDetails(<span class="type">Instant</span>.now())

    <span class="kw">return</span> <span class="type">Mono</span>.defer { <span class="type">Mono</span>.just(initialJobDetails) }
        <span class="cmt">// Stage 1: Start the job (check for existing running jobs)</span>
        .flatMap { job -&gt; job isStillRunning { cronJobTracker.startJob(job) } }
        .checkpoint(<span class="str">"Stage 1: Check if job is already running"</span>)

        <span class="cmt">// Stage 2: Find and validate the best file</span>
        .flatMap { job -&gt; job isStillRunning { cronEdsFiles.findBestFile(job) } }
        .flatMap { job -&gt; job isStillRunning { cronEdsFiles.isFileValid(job) } }
        .checkpoint(<span class="str">"Stage 2: Find best &amp; valid file"</span>)

        <span class="cmt">// Stage 3: Do the actual import</span>
        .flatMap { job -&gt; job isStillRunning { cronEdsVehicleImporter.doVehicleImport(job) } }
        .checkpoint(<span class="str">"Stage 3: Perform the temp import"</span>)

        <span class="cmt">// Stage 4: Post-import tasks</span>
        .flatMap { job -&gt; job isStillRunning { cronEdsVehicleImporter.markAndSweep(job) } }
        .flatMap { job -&gt; job isStillRunning { mono { cronSearchSuggestions.updateSearchSuggestions(job) } } }
        .checkpoint(<span class="str">"Stage 4: Post job tasks"</span>)

        <span class="cmt">// Happy path: mark job as succeeded</span>
        .flatMap { job -&gt;
            <span class="kw">val</span> successfulJob = job.copy(status = <span class="type">JobStatus</span>.SUCCEEDED)
            cronJobTracker.endJob(successfulJob)
        }

        <span class="cmt">// Error handling: catch JobExceptions and gracefully close the job</span>
        .onErrorResume(<span class="type">JobException</span>::<span class="kw">class</span>.java) { e -&gt;
            <span class="kw">val</span> failedJob = e.relatedJob.completeWithJobException(e)
            cronJobTracker.endJob(failedJob)    <span class="cmt">// Always persist the final job status</span>
        }
        .checkpoint(<span class="str">"Finalize job outcomes"</span>)
}
</code></pre>

<h4>The isStillRunning Guard Pattern</h4>

<p>This is a clever Kotlin <em>infix function</em> that prevents executing subsequent stages if a
previous stage failed. It's used as a pipeline guard:</p>

<pre><code><span class="cmt">// This infix function reads like English: "job isStillRunning { nextStage() }"</span>
<span class="kw">infix fun</span> <span class="type">InventoryJobDetails</span>.<span class="fn">isStillRunning</span>(
    codeToRun: () -&gt; <span class="type">Mono</span>&lt;<span class="type">InventoryJobDetails</span>&gt;
): <span class="type">Mono</span>&lt;<span class="type">InventoryJobDetails</span>&gt; =
    <span class="kw">when</span> (<span class="kw">this</span>.status) {
        <span class="type">JobStatus</span>.RUNNING -&gt; {
            <span class="kw">try</span> {
                codeToRun()     <span class="cmt">// Execute the next stage</span>
            } <span class="kw">catch</span> (e: <span class="type">JobException</span>) {
                <span class="type">Mono</span>.error(e)   <span class="cmt">// Wrap in Mono.error for the reactive chain</span>
            } <span class="kw">catch</span> (e: <span class="type">Exception</span>) {
                <span class="type">Mono</span>.error(<span class="type">JobException</span>(<span class="kw">this</span>, <span class="type">JobStatus</span>.FAILED, e.message ?: <span class="str">"&lt;null&gt;"</span>))
            }
        }
        <span class="kw">else</span> -&gt; {
            <span class="type">Mono</span>.error(<span class="type">JobException</span>(<span class="kw">this</span>, status, <span class="kw">this</span>.statusDesc ?: <span class="str">"&lt;null&gt;"</span>))
        }
    }
</code></pre>

<h4>The Staged Import with Semaphore Concurrency (CronEdsVehicleImporter.kt)</h4>

<p>The import uses Kotlin coroutines with a <code>Semaphore</code> to limit concurrent MongoDB writes to 5:</p>

<pre><code><span class="kw">suspend fun</span> <span class="fn">coDoVehicleImport</span>(jobDetails: <span class="type">InventoryJobDetails</span>): <span class="type">InventoryJobDetails</span> {
    <span class="cmt">// 1. Fetch supporting data (categories, shipping config)</span>
    <span class="kw">val</span> categoryList = categoryDatabase.read().collectList().block().orEmpty()
    <span class="kw">val</span> shippingConfig = taxAndFeeClient.getShippingConfig()

    <span class="cmt">// 2. Create a temporary collection in MongoDB</span>
    <span class="kw">val</span> tempImport = vehicleDao.createTempImport()

    <span class="cmt">// 3. Download, parse, and upload in concurrent batches</span>
    <span class="kw">val</span> csvSemaphore = <span class="type">Semaphore</span>(permits = <span class="num">5</span>)  <span class="cmt">// Max 5 concurrent batches</span>

    fileStorage.createImportFileWrapper(jobDetails.filePath!!).use { importFile -&gt;
        <span class="kw">val</span> rows = csvToExtractedRowConverter.parseToRows(importFile.downloadAndGetReader())

        rows
            .map { row -&gt; extractedRowToVehicleConverter.convertToVehicle(row, ...) }
            .chunked(<span class="num">500</span>)           <span class="cmt">// Batch into groups of 500</span>
            .map { chunk -&gt;
                async {              <span class="cmt">// Launch coroutine for each batch</span>
                    csvSemaphore.withPermit {  <span class="cmt">// But only 5 at a time</span>
                        tempImport
                            .addVehicles(chunk)
                            .collectList()
                            .awaitFirst()
                    }
                }
            }
            .awaitAll()              <span class="cmt">// Wait for all batches (like Promise.all)</span>
    }

    <span class="cmt">// 4. Safety check → Publish deltas → Merge → Clean up</span>
    <span class="kw">return</span> tempImportWork
        .then(safetyChecks)
        .then(publishDeltasWork)
        .then(mergeVehiclesToLiveCollection)
        .then(getTempImportCountsWork)
        .awaitFirst()
}
</code></pre>

<!-- LEASE EXPIRY -->
<h3 id="cron-leasing" class="reveal">Lease Expiry Processing (CronLeasing.kt)</h3>

<p>After the EDS import completes, the system checks all leasable vehicles for expired leasing data.
This is a pure reactive stream processing pipeline:</p>

<pre><code><span class="kw">fun</span> <span class="fn">applyLeaseExpiries</span>(): <span class="type">Mono</span>&lt;<span class="type">Long</span>&gt; =
    vehicleDao
        .getLeasableVehicles()                   <span class="cmt">// Flux&lt;Vehicle&gt; - ALL leasable vehicles</span>
        .buffer(<span class="num">100</span>)                             <span class="cmt">// Batch for backpressure</span>
        .flatMapIterable { it }                  <span class="cmt">// Flatten back to individual vehicles</span>
        .transformDeferred { vehicleFlux -&gt;
            vehicleFlux
                .filter { vehicle -&gt;             <span class="cmt">// Keep only vehicles with expired regions</span>
                    vehicle.leasing?.regionalPrices?.any {
                        <span class="type">Instant</span>.parse(it.expiresOn).isBefore(<span class="type">Instant</span>.now())
                    } ?: <span class="kw">false</span>
                }
                .map { vehicle -&gt;                <span class="cmt">// Remove expired regions from the vehicle</span>
                    <span class="kw">val</span> activePrograms = vehicle.leasing?.regionalPrices?.filter {
                        <span class="type">Instant</span>.parse(it.expiresOn).isAfter(<span class="type">Instant</span>.now())
                    }
                    <span class="kw">val</span> canLease = !activePrograms.isNullOrEmpty()
                    <span class="kw">val</span> defaultPrice = activePrograms
                        ?.firstOrNull { it.regionId == <span class="type">RegionData</span>.defaultRegionId }
                        ?.amountInCents
                    vehicle.copy(
                        leasing = vehicle.leasing?.copy(
                            canLease = canLease,
                            defaultPrice = defaultPrice,
                            regionalPrices = activePrograms
                        )
                    )
                }
        }
        .buffer(<span class="num">100</span>)                             <span class="cmt">// Re-batch for bulk write</span>
        .flatMap { vehicleDao.upsertVehicles(it) }  <span class="cmt">// Write back to DB</span>
        .count()                                 <span class="cmt">// Count total updated</span>
</code></pre>

<div class="callout callout-success reveal">
    <div class="callout-title">Business Logic: How Leasing Works</div>
    <p>Each vehicle can have leasing data with <strong>regional prices</strong>. Each region has an <code>expiresOn</code> timestamp.
    When all regions expire, the vehicle's <code>canLease</code> becomes <code>false</code>.
    Region 1 is the "default" price used as a fallback if no region-specific price is found for a user's location.</p>
</div>

<!-- REGION SYNC -->
<h3 id="cron-region" class="reveal">Postal Code Region Sync (PostalCodeOemRegionSync.kt)</h3>

<p>This job syncs OEM region mappings from the Incentives API. It maps postal codes to OEM regions
so that leasing prices can be looked up by the user's ZIP code:</p>

<pre><code><span class="kw">fun</span> <span class="fn">updateRegionData</span>(): <span class="type">Mono</span>&lt;<span class="type">Void</span>&gt; {
    <span class="kw">val</span> timestamp = <span class="type">Instant</span>.now().toString()

    <span class="kw">return</span> incentivesClient
        .getRegions()                           <span class="cmt">// Flux&lt;Region&gt; from Incentives API</span>
        .map { region -&gt;                        <span class="cmt">// Invert: Region→PostalCodes to PostalCode→Regions</span>
            region.postalCodes.map { postalCode -&gt;
                region.makes.map { make -&gt;
                    <span class="type">PostalCodeOemRegion</span>(postalCode, mapOf(make to region.id), timestamp)
                }
            }.flatten()
        }
        .collectList()                          <span class="cmt">// Flux → Mono&lt;List&gt;</span>
        .map { it.flatten().associateByMerged(...) }  <span class="cmt">// Merge by postal code</span>
        .flatMap { incentives -&gt;
            postalCodeOemRegionsDao
                .upsertRegions(incentives.values.toList())
                .collectList()
                .then(postalCodeOemRegionsDao.pruneOldRecords(timestamp))
        }
        .then()                                 <span class="cmt">// Discard result, just complete</span>
}
</code></pre>

<!-- CLEANUP -->
<h3 id="cron-cleanup" class="reveal">Database Cleanup Jobs</h3>

<h4>Stale Record Cleanup (hourly)</h4>
<p>Deletes all vehicles where <code>status == DELETED</code>. These were marked during the mark-and-sweep
phase of the EDS import.</p>

<pre><code><span class="kw">fun</span> <span class="fn">removeStaleRecords</span>() {
    vehicleDaoRouter.alternateVehicleCollections.map { (key, dao) -&gt;
        dao.cleanUpDeletedRecords()     <span class="cmt">// Mono&lt;DeleteResult&gt;</span>
            .doOnNext { log.info(<span class="str">"Cleaned up ${it.deletedCount} from '$key'"</span>) }
            .block()
    }
}
</code></pre>

<h4>Temp Collection Cleanup (daily)</h4>
<p>Drops any <code>temp_vehicle*</code> collections older than 28 days. These are leftover from failed or
completed EDS imports:</p>

<pre><code><span class="kw">private suspend fun</span> <span class="fn">coRemoveStaleTempCollections</span>() {
    <span class="kw">val</span> thresholdInstant = <span class="type">Instant</span>.now().minusSeconds(<span class="num">60 * 60 * 24 * 7 * 4</span>) <span class="cmt">// 28 days ago</span>

    <span class="kw">val</span> tempCollections = mongoDatabase
        .listCollectionNames()
        .toFlux()
        .filter { it.startsWith(<span class="str">"temp_vehicle"</span>) }  <span class="cmt">// Only temp collections</span>
        .collectList()
        .awaitFirst()

    <span class="cmt">// Parse timestamp from collection name, filter old ones, drop them</span>
    staleCollections.map { name -&gt;
        coroutineScope {
            launch {
                semaphore.withPermit {
                    mongoDatabase.getCollectionOfName&lt;<span class="type">Vehicle</span>&gt;(name)
                        .drop()
                        .toMono()
                        .awaitSingleOrNull()
                }
            }
        }
    }
}
</code></pre>

<h3 id="cron-metrics" class="reveal">Metric Updates</h3>
<p>Every 5 minutes, the spin count metric is updated for DataDog monitoring. This counts how many vehicles
have 360-degree photos from Impel/SpinCar.</p>

<hr>

<!-- ==================== AZURE ==================== -->
<h2 id="azure-blob" class="reveal">Azure Blob Storage</h2>

<p>Azure Blob Storage is where the <strong>EDS TSV inventory files</strong> are stored. The cron job downloads
the newest GZIP-compressed TSV file from the <code>inbound</code> container:</p>

<pre><code><span class="ann">@Component</span>
<span class="kw">class</span> <span class="type">AzureEdsFileStorage</span>(
    azureBlobConfig: <span class="type">AzureBlobConfig</span>,
    blobServiceClientBuilder: <span class="type">BlobServiceClientBuilder</span>
) : <span class="type">FileStorage</span>&lt;<span class="type">EdsExtractedInventoryRow</span>&gt;() {

    <span class="cmt">// Connect to Azure Blob Storage</span>
    <span class="kw">private val</span> blobServiceClient = blobServiceClientBuilder
        .connectionString(azureBlobConfig.edsTsv.connectionString)
        .buildClient()

    <span class="kw">private val</span> container = blobServiceClient
        .getBlobContainerClient(azureBlobConfig.edsTsv.containerName)  <span class="cmt">// "inbound"</span>

    <span class="cmt">// Find the newest file by parsing timestamps from filenames</span>
    <span class="kw">override fun</span> <span class="fn">newestFileName</span>(context: <span class="type">ProcessContext</span>): <span class="type">String</span>? {
        <span class="kw">val</span> blobFiles = container.listBlobs(listBlobOptions, blobTimeout)
        <span class="kw">return</span> blobFiles.maxByOrNull { fileNameToTimestamp(it.name) }?.name
    }

    <span class="cmt">// Download file to local temp file, decompress GZIP, return Reader</span>
    <span class="kw">inner class</span> <span class="type">EdsImportFile</span>(<span class="kw">private val</span> targetFile: <span class="type">String</span>) : <span class="type">ImportFile</span>() {
        <span class="kw">override fun</span> <span class="fn">downloadAndGetReader</span>(): <span class="type">Reader</span> {
            tempFile.outputStream().use { fileOutputStream -&gt;
                container.getBlobClient(targetFile).downloadStream(fileOutputStream)
            }
            <span class="kw">return</span> <span class="type">GZIPInputStream</span>(tempFile.inputStream()).bufferedReader()
        }
    }
}
</code></pre>

<div class="callout callout-info reveal">
    <div class="callout-title">Local Development: Azurite</div>
    <p>Locally, Azure Blob Storage is replaced by <strong>Azurite</strong> (an Azure Storage emulator) running on port 10010 via Docker Compose.
    The laptop profile uses a hardcoded Azurite connection string.</p>
</div>

<!-- SERVICE BUS -->
<h2 id="azure-sb" class="reveal">Azure Service Bus</h2>

<p>Azure Service Bus is the message broker. Odyssey uses <strong>4 topics</strong> for asynchronous communication:</p>

<table>
    <tr><th>Topic</th><th>Publisher</th><th>Subscriber</th><th>Purpose</th></tr>
    <tr>
        <td><code>inventory-delta-topic</code></td>
        <td>cron</td>
        <td>F&amp;I (external)</td>
        <td>Vehicle price/mileage/add/delete changes</td>
    </tr>
    <tr>
        <td><code>leasing-incentives-topic</code></td>
        <td>Leasing service (external)</td>
        <td>consumer</td>
        <td>Leasing pricing updates per vehicle</td>
    </tr>
    <tr>
        <td><code>cart-status-update-topic</code></td>
        <td>Cart service (external)</td>
        <td>availability</td>
        <td>Vehicle purchase-pending status changes</td>
    </tr>
    <tr>
        <td><code>vehicle-data-topic</code></td>
        <td>Various</td>
        <td>search</td>
        <td>Vehicle data updates</td>
    </tr>
</table>

<h4>Message Sender Pattern</h4>
<p>The codebase uses a <strong>strategy pattern</strong> with Spring profiles to switch between real and dummy senders:</p>

<pre><code><span class="cmt">// Interface</span>
<span class="kw">interface</span> <span class="type">MessageSender</span>&lt;<span class="type">T</span>&gt; {
    <span class="kw">fun</span> <span class="fn">sendMessage</span>(messageContents: <span class="type">T</span>): <span class="type">Mono</span>&lt;<span class="type">T</span>&gt;
    <span class="kw">fun</span> <span class="fn">sendMessages</span>(messageContents: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;): <span class="type">Flux</span>&lt;<span class="type">T</span>&gt;
}

<span class="cmt">// Real implementation (dev, uat, prod)</span>
<span class="ann">@Component</span>
<span class="ann">@Profile("dev", "uat", "prod")</span>
<span class="kw">class</span> <span class="type">InventoryDeltaTopicSender</span> :
    <span class="type">ServiceBusMessageSender</span>&lt;<span class="type">InventoryDelta</span>&gt;(...), <span class="type">DeltaMessageSender</span>

<span class="cmt">// Dummy implementation (laptop) - just logs and returns the value</span>
<span class="ann">@Component</span>
<span class="ann">@Profile("laptop")</span>
<span class="kw">class</span> <span class="type">DummyDeltaTopicSender</span> :
    <span class="type">DummyMessageSender</span>&lt;<span class="type">InventoryDelta</span>&gt;(...), <span class="type">DeltaMessageSender</span>
</code></pre>

<p>The real <code>ServiceBusMessageSender</code> uses Azure's async client:</p>

<pre><code><span class="kw">open class</span> <span class="type">ServiceBusMessageSender</span>&lt;<span class="type">T</span> : <span class="type">Any</span>&gt;(
    <span class="kw">private val</span> configDetails: <span class="type">MessagingConfig</span>.<span class="type">Details</span>,
    <span class="kw">private val</span> objectMapper: <span class="type">ObjectMapper</span> = jacksonObjectMapper()
) : <span class="type">MessageSender</span>&lt;<span class="type">T</span>&gt; {

    <span class="kw">private lateinit var</span> client: <span class="type">ServiceBusSenderAsyncClient</span>

    <span class="ann">@PostConstruct</span>
    <span class="kw">fun</span> <span class="fn">postConstruct</span>() {
        client = <span class="type">ServiceBusClientBuilder</span>()
            .connectionString(configDetails.connectionString)
            .sender()
            .buildAsyncClient()    <span class="cmt">// Async client = returns Mono (non-blocking)</span>
    }

    <span class="kw">override fun</span> <span class="fn">sendMessage</span>(messageContents: <span class="type">T</span>): <span class="type">Mono</span>&lt;<span class="type">T</span>&gt; =
        client
            .sendMessage(<span class="type">ServiceBusMessage</span>(objectMapper.writeValueAsBytes(messageContents)))
            .then(<span class="type">Mono</span>.just(messageContents))    <span class="cmt">// Return the original message after send</span>
}
</code></pre>

<!-- CONSUMER MODULE -->
<h3 id="azure-sb-consumer" class="reveal">Consumer Module: Leasing/Incentives Messages</h3>

<p>The consumer module listens to the <code>leasing-incentives-topic</code> for updates to vehicle leasing data.
It uses the <strong>Lithia ASB library</strong> (<code>DrivewayAsbReceiver</code>) which provides a builder pattern
for configuring topic subscriptions:</p>

<pre><code><span class="ann">@Component</span>
<span class="kw">class</span> <span class="type">LeaseTopicReceiver</span>(...) : <span class="type">ApplicationListener</span>&lt;<span class="type">ApplicationStartedEvent</span>&gt; {

    <span class="kw">override fun</span> <span class="fn">onApplicationEvent</span>(event: <span class="type">ApplicationStartedEvent</span>) {
        receiverProvider
            .newReceiver&lt;<span class="type">JsonNode</span>&gt;()
            .topicName(config.topicName)              <span class="cmt">// "leasing-incentives-topic"</span>
            .subscriptionName(config.subscriptionName) <span class="cmt">// "lease-consumer-sub"</span>
            .connectionString(config.connectionString)
            .maximumRetryCount(config.maximumRetries)  <span class="cmt">// 5 retries</span>
            .converter { objectMapper.readTree(it.body.toBytes()).toMono() }
            .messageHandler { message -&gt;
                processor.process(message)             <span class="cmt">// Route to LeaseHandler or IncentivesHandler</span>
                    .map { <span class="type">HandlerResult</span>.Success }
                    .switchIfEmpty(<span class="type">Mono</span>.just(<span class="type">HandlerResult</span>.Success))
                    .onErrorContinue { throwable, _ -&gt;
                        <span class="type">HandlerResult</span>.RetryableError(immediatelyRetry = <span class="kw">false</span>, throwable, ...)
                    }
            }
            .build()
            .start()
    }
}
</code></pre>

<p>The <code>LeaseHandler</code> updates the vehicle's leasing field:</p>

<pre><code><span class="kw">fun</span> <span class="fn">handle</span>(message: <span class="type">LeaseIncentivesMessage</span>): <span class="type">Mono</span>&lt;<span class="type">Vehicle</span>&gt; =
    vehicleDao.getByVin(message.vin)
        .map { vehicle -&gt;
            <span class="kw">when</span> (!message.data.isNullOrEmpty()) {
                <span class="kw">true</span> -&gt; {
                    <span class="kw">if</span> (vehicle.vehicleCondition != <span class="type">VehicleCondition</span>.NEW) {
                        <span class="type">Leasing</span>(canLease = <span class="kw">false</span>)  <span class="cmt">// Only NEW cars can lease</span>
                    } <span class="kw">else</span> {
                        <span class="type">Leasing</span>(canLease = <span class="kw">true</span>, defaultPrice = ..., regionalPrices = ...)
                    }
                }
                <span class="kw">else</span> -&gt; <span class="type">Leasing</span>(canLease = <span class="kw">false</span>)
            }
        }
        .flatMap { leaseField -&gt;
            vehicleDao.updateVehicleField(message.vin, <span class="type">Vehicle</span>::leasing, leaseField)
        }
</code></pre>

<!-- AVAILABILITY MODULE -->
<h3 id="azure-sb-availability" class="reveal">Availability Module: Cart Status</h3>

<p>The availability module listens to <code>cart-status-update-topic</code> for purchase-pending status changes.
When a customer adds a vehicle to their cart, the <code>purchasePending</code> flag is set to prevent others
from purchasing the same vehicle:</p>

<pre><code><span class="ann">@Component</span>
<span class="kw">class</span> <span class="type">AvailabilityRequestHandler</span>(...) {

    <span class="kw">suspend fun</span> <span class="fn">handle</span>(message: <span class="type">CartStatusUpdateNotificationMessage</span>): <span class="type">HandlerResult</span> {
        <span class="cmt">// 1. Find the vehicle</span>
        <span class="kw">val</span> vehicle = vehicleDao.getByVin(message.vin).awaitSingleOrNull()
            ?: <span class="kw">return</span> <span class="type">HandlerResult</span>.Success  <span class="cmt">// Vehicle not in inventory, skip</span>

        <span class="cmt">// 2. Check for stale messages (out-of-order delivery protection)</span>
        <span class="kw">val</span> lastEnqueuedTime = vehicle.availability?.enqueuedTime
        <span class="kw">return if</span> (lastEnqueuedTime == <span class="kw">null</span> || lastEnqueuedTime &lt; message.enqueuedTime) {
            <span class="cmt">// Message is newer → apply it</span>
            availabilityProcessor.updatePurchasePending(message).awaitSingleOrNull()
            <span class="type">HandlerResult</span>.Success
        } <span class="kw">else</span> {
            <span class="cmt">// Stale message → skip it</span>
            log.warn(<span class="str">"Stale message: ${message.enqueuedTime} precedes ${lastEnqueuedTime}"</span>)
            <span class="type">HandlerResult</span>.Success
        }
    }
}
</code></pre>

<div class="callout callout-info reveal">
    <div class="callout-title">Stale Message Detection</div>
    <p>Messages can arrive out of order on Service Bus. The handler compares the <code>enqueuedTime</code> of the incoming
    message with the <code>enqueuedTime</code> stored on the vehicle. If the incoming message is older, it's silently discarded.
    This prevents a "remove from cart" message from being processed after an "add to cart" message.</p>
</div>

<hr>

<!-- ==================== MONGODB ==================== -->
<h2 id="mongo-config" class="reveal">MongoDB: KMongo Reactive Configuration</h2>

<p>MongoDB is accessed via <strong>KMongo Reactor</strong> (not Spring Data MongoDB). The configuration creates
a reactive MongoDB client and 22+ indexes for query optimization:</p>

<pre><code><span class="ann">@Configuration</span>
<span class="ann">@ConfigurationProperties(prefix = "mongo")</span>
<span class="ann">@EnableReactiveMongoRepositories</span>(basePackages = [<span class="str">"com.lithia.odyssey"</span>])
<span class="kw">class</span> <span class="type">MongoConfig</span> : <span class="type">AbstractReactiveMongoConfiguration</span>() {
    <span class="kw">lateinit var</span> atlasConnString: <span class="type">String</span>
    <span class="kw">var</span> inventoryDatabaseName: <span class="type">String</span> = <span class="str">"shopInventory"</span>

    <span class="cmt">// KMongo.createClient returns a reactive MongoDB client</span>
    <span class="ann">@Bean</span>
    <span class="kw">override fun</span> <span class="fn">reactiveMongoClient</span>(): <span class="type">MongoClient</span> {
        <span class="kw">return</span> <span class="type">KMongo</span>.createClient(atlasConnString)
    }

    <span class="cmt">// Recommended indexes (based on MongoDB's query analyzer suggestions)</span>
    <span class="kw">val</span> mongoRecommendedIndexes = listOf(
        <span class="type">MongoIndex</span>(mapOf(
            <span class="type">Vehicle</span>::status to <span class="num">1</span>,
            <span class="type">Vehicle</span>::vehicleCondition to <span class="num">1</span>,
            <span class="type">Vehicle</span>::manuallySuppressed to <span class="num">1</span>,
            <span class="type">Vehicle</span>::price to <span class="num">1</span>,
            <span class="type">Vehicle</span>::ymmt / <span class="type">Ymmt</span>::year to <span class="num">1</span>
        )),
        <span class="cmt">// ... 15 more compound indexes</span>
    )
}
</code></pre>

<h3 id="mongo-dao" class="reveal">VehicleDao: The Repository Pattern</h3>

<p>KMongo provides Kotlin-idiomatic MongoDB operations. Notice how Kotlin's property references
(<code>Vehicle::vin</code>) are used instead of string field names:</p>

<pre><code><span class="cmt">// KMongo type-safe queries vs raw MongoDB:</span>

<span class="cmt">// KMongo (Kotlin):      Vehicle::vin eq "ABC123"</span>
<span class="cmt">// Raw MongoDB (JS):     { vin: { $eq: "ABC123" } }</span>

<span class="cmt">// KMongo nested path:   Vehicle::ymmt / Ymmt::make eq "Toyota"</span>
<span class="cmt">// Raw MongoDB (JS):     { "ymmt.make": { $eq: "Toyota" } }</span>

<span class="cmt">// KMongo set field:     Vehicle::status setTo InventoryStatus.DELETED</span>
<span class="cmt">// Raw MongoDB (JS):     { $set: { status: "DELETED" } }</span>
</code></pre>

<h3 id="mongo-temp" class="reveal">Temp Import Strategy</h3>

<p>The EDS import uses a <strong>temporary collection</strong> pattern to safely import vehicles without
corrupting the live data. This is implemented as an inner class:</p>

<pre><code><span class="kw">inner class</span> <span class="type">TempImportImpl</span>(...) : <span class="type">VehicleDao</span>.<span class="type">TempImport</span> {
    <span class="cmt">// Generate unique name: temp_vehicleV3_20260216T143000.000000Z</span>
    <span class="kw">override val</span> tempCollectionName = <span class="str">"temp_${targetCollectionName}_$tempDatetime"</span>

    <span class="cmt">// Merge temp → live, preserving critical fields</span>
    <span class="kw">override fun</span> <span class="fn">mergeToVehicles</span>(): <span class="type">Mono</span>&lt;<span class="type">Void</span>&gt; {
        <span class="kw">return</span> tempCollection.find()
            .sort(<span class="type">Document</span>(<span class="type">Vehicle</span>::vin.path(), <span class="num">1</span>))
            .toFlux()
            .limitRate(<span class="num">100</span>)                        <span class="cmt">// Backpressure: request 100 at a time</span>
            .transform { recordsFlux -&gt;
                <span class="cmt">// Match each incoming vehicle with its existing version</span>
                recordPairOperations.matchRecordsFor(recordsFlux) { getByVin(it.vin) }
            }
            .transform(recordPairOperations::combineRecords)  <span class="cmt">// Preserve leasing, suppression, etc.</span>
            .flatMap(::upsertVehicle)
            .retryWhen(
                <span class="type">Retry</span>.backoff(<span class="num">5</span>, <span class="type">Duration</span>.ofSeconds(<span class="num">5</span>))  <span class="cmt">// Retry with exponential backoff</span>
            )
            .then()
    }
}
</code></pre>

<h3 id="mongo-aggregation" class="reveal">MongoDB Aggregation Pipeline DSL</h3>

<p>Odyssey has a custom <strong>type-safe DSL</strong> for building MongoDB aggregation pipelines.
This is used primarily for Atlas Search queries. Instead of writing raw JSON, developers compose
pipelines using Kotlin classes:</p>

<pre><code><span class="cmt">// The DSL lets you build MongoDB aggregation stages like this:</span>

<span class="cmt">// Atlas Search query with compound operators</span>
<span class="kw">val</span> searchPipeline = <span class="type">Pipeline</span>&lt;<span class="type">Vehicle</span>&gt;()
    .addStage(<span class="type">SearchBlock</span>(
        index = <span class="str">"shopSearch"</span>,
        compound = <span class="type">CompoundBlock</span>(
            must = listOf(
                <span class="type">TextBlock</span>(query = <span class="str">"Toyota Camry"</span>, path = <span class="str">"makeModel"</span>),
                <span class="type">EqualsBlock</span>(value = <span class="str">"ACTIVE"</span>, path = <span class="str">"status"</span>)
            ),
            should = listOf(
                <span class="type">NearBlock</span>(origin = <span class="num">0</span>, path = <span class="str">"price"</span>, pivot = <span class="num">5000</span>)
            ),
            mustNot = listOf(
                <span class="type">EqualsBlock</span>(value = <span class="kw">true</span>, path = <span class="str">"manuallySuppressed"</span>)
            )
        )
    ))
    .toMongoQuery()  <span class="cmt">// Converts to List&lt;Bson&gt; for MongoDB driver</span>

<span class="cmt">// This generates MongoDB aggregation JSON like:</span>
<span class="cmt">// { $search: { index: "shopSearch", compound: { must: [...], should: [...] } } }</span>
</code></pre>

<hr>

<!-- ==================== TESTING ==================== -->
<h2 id="testing-overview" class="reveal">Testing Patterns</h2>

<p>Odyssey uses a specific testing stack and conventions. Understanding these patterns will help you
write and read tests effectively.</p>

<table>
    <tr><th>Framework</th><th>Purpose</th><th>JS Equivalent</th></tr>
    <tr><td>JUnit 5 (Jupiter)</td><td>Test runner</td><td>Jest</td></tr>
    <tr><td>MockK</td><td>Mocking framework</td><td>jest.mock() / sinon</td></tr>
    <tr><td>StepVerifier</td><td>Reactive stream assertions</td><td>No direct equivalent</td></tr>
    <tr><td>Kotest</td><td>Additional assertions</td><td>chai</td></tr>
    <tr><td>Spring Boot Test</td><td>Integration testing</td><td>supertest</td></tr>
</table>

<!-- STEP VERIFIER -->
<h3 id="testing-stepverifier" class="reveal">StepVerifier: Testing Reactive Streams</h3>

<p><code>StepVerifier</code> is the most important testing tool in a reactive codebase. It lets you
subscribe to a Mono/Flux and assert what values are emitted, in what order, and how the stream
terminates:</p>

<pre><code><span class="cmt">// PATTERN 1: Assert a specific value is emitted, then stream completes</span>
<span class="type">StepVerifier</span>.create(cronLeasing.applyLeaseExpiries())  <span class="cmt">// Subscribe to the Mono&lt;Long&gt;</span>
    .expectNext(<span class="num">0</span>)                                      <span class="cmt">// Expect the value 0 to be emitted</span>
    .expectComplete()                                   <span class="cmt">// Expect the stream to complete</span>
    .verify()                                            <span class="cmt">// Execute (triggers subscription)</span>

<span class="cmt">// PATTERN 2: Assert using a predicate (matcher)</span>
<span class="type">StepVerifier</span>.create(flow)
    .expectNextMatches { jobDetails -&gt;
        jobDetails.status == <span class="type">JobStatus</span>.FAILED           <span class="cmt">// Custom assertion on the emitted value</span>
    }
    .expectComplete()
    .verify()

<span class="cmt">// PATTERN 3: Assert an error is emitted</span>
<span class="type">StepVerifier</span>.create(mono)
    .expectError(<span class="type">NoSuchElementException</span>::<span class="kw">class</span>.java)  <span class="cmt">// Expect this error type</span>
    .verify()

<span class="cmt">// PATTERN 4: Assert multiple values in a Flux</span>
<span class="type">StepVerifier</span>.create(flux)
    .expectNext(vehicle1)                               <span class="cmt">// First emission</span>
    .expectNext(vehicle2)                               <span class="cmt">// Second emission</span>
    .expectComplete()
    .verify()
</code></pre>

<div class="callout callout-warn reveal">
    <div class="callout-title">Why not just use .block() in tests?</div>
    <p>You <em>could</em> use <code>.block()</code> and then assert on the result, but StepVerifier is better because:
    (1) it tests the timing and ordering of emissions, (2) it properly handles empty Monos,
    (3) it can assert on error signals, and (4) it can verify side-effects like subscription timing.</p>
</div>

<!-- MOCKK -->
<h3 id="testing-mockk" class="reveal">MockK: Mocking Dependencies</h3>

<p>MockK is the Kotlin mocking library (equivalent to Jest mocks). Here are the patterns used in Odyssey:</p>

<pre><code><span class="cmt">// SETUP: Initialize mocks before each test</span>
<span class="ann">@MockK</span>
<span class="kw">lateinit var</span> mockVehicleDao: <span class="type">VehicleDao</span>     <span class="cmt">// Declare mock via annotation</span>

<span class="ann">@BeforeEach</span>
<span class="kw">fun</span> <span class="fn">setup</span>() {
    <span class="type">MockKAnnotations</span>.init(<span class="kw">this</span>)               <span class="cmt">// Initialize @MockK fields</span>
    clearAllMocks()                              <span class="cmt">// Reset all mock state</span>
}

<span class="cmt">// STUBBING: Tell mocks what to return</span>
every { mockVehicleDao.getLeasableVehicles() } returns <span class="type">Flux</span>.just(vehicle1, vehicle2)
every { mockVehicleDao.upsertVehicles(any()) } returns <span class="type">Flux</span>.just(vehicle1)

<span class="cmt">// STUBBING COROUTINES: Use coEvery for suspend functions</span>
coEvery { mockSearchSuggestions.updateSearchSuggestions(any()) } returns jobDetails

<span class="cmt">// STUBBING WITH DYNAMIC RETURN: Use 'answers' for complex logic</span>
every { mockJobTracker.endJob(any()) } answers {
    <span class="type">Mono</span>.just(<span class="kw">this</span>.args[<span class="num">0</span>] <span class="kw">as</span> <span class="type">InventoryJobDetails</span>)  <span class="cmt">// Return whatever was passed in</span>
}

<span class="cmt">// VERIFICATION: Assert that methods were called</span>
verify(exactly = <span class="num">1</span>) { mockVehicleDao.upsertVehicles(listOf(expectedVehicle)) }
verify(exactly = <span class="num">0</span>) { mockVehicleDao.upsertVehicles(any()) }  <span class="cmt">// Never called</span>

<span class="cmt">// VERIFICATION WITH MATCHER</span>
verify { mockJobTracker.endJob(match { it.status == <span class="type">JobStatus</span>.FAILED }) }
</code></pre>

<!-- FULL TEST EXAMPLES -->
<h3 id="testing-examples" class="reveal">Full Test Example: CronLeasingTest</h3>

<p>Here's a complete test from the actual codebase that demonstrates all the patterns together.
This test verifies the lease expiry logic handles expired leasing data correctly:</p>

<pre><code><span class="kw">class</span> <span class="type">CronLeasingTest</span> {

    <span class="ann">@MockK</span> <span class="kw">lateinit var</span> mockVehicleDaoRouter: <span class="type">VehicleDaoRouter</span>
    <span class="ann">@MockK</span> <span class="kw">lateinit var</span> mockVehicleDao: <span class="type">VehicleDao</span>
    <span class="kw">lateinit var</span> cronLeasing: <span class="type">CronLeasing</span>

    <span class="ann">@BeforeEach</span>
    <span class="kw">fun</span> <span class="fn">setup</span>() {
        <span class="type">MockKAnnotations</span>.init(<span class="kw">this</span>)
        clearAllMocks()
        every { mockVehicleDaoRouter.getDaoByCollectionName(any()) } returns mockVehicleDao
        cronLeasing = <span class="type">CronLeasing</span>(mockVehicleDaoRouter)
    }

    <span class="ann">@Test</span>
    <span class="kw">fun</span> <span class="fn">`etl flow handles records with ALL expired leasing data`</span>() {
        <span class="cmt">// ARRANGE: Create a vehicle with expired leasing data</span>
        <span class="kw">val</span> expired = <span class="type">RegionData</span>(<span class="num">2</span>, <span class="num">444</span>, <span class="type">Instant</span>.now().minusSeconds(<span class="num">20</span>).toString())
        <span class="kw">val</span> expiredB = <span class="type">RegionData</span>(<span class="num">3</span>, <span class="num">555</span>, <span class="type">Instant</span>.now().minusSeconds(<span class="num">20</span>).toString())
        <span class="kw">val</span> inputVehicle = <span class="type">Vehicle</span>(vin = <span class="str">"vin"</span>).copy(
            leasing = <span class="type">Leasing</span>(
                canLease = <span class="kw">true</span>,
                defaultPrice = expired.amountInCents,
                regionalPrices = listOf(expired, expiredB)
            )
        )

        <span class="cmt">// Expected: canLease becomes false, all regions removed</span>
        <span class="kw">val</span> expectedOutput = inputVehicle.copy(
            leasing = <span class="type">Leasing</span>(canLease = <span class="kw">false</span>, defaultPrice = <span class="kw">null</span>, regionalPrices = listOf())
        )

        <span class="cmt">// Stub the DAO</span>
        every { mockVehicleDao.getLeasableVehicles() } returns <span class="type">Flux</span>.just(inputVehicle)
        every { mockVehicleDao.upsertVehicles(any()) } returns <span class="type">Flux</span>.just(inputVehicle)

        <span class="cmt">// ACT + ASSERT: Use StepVerifier to test the reactive pipeline</span>
        <span class="type">StepVerifier</span>.create(cronLeasing.applyLeaseExpiries())
            .expectNext(<span class="num">1</span>)          <span class="cmt">// 1 vehicle was updated</span>
            .expectComplete()
            .verify()

        <span class="cmt">// VERIFY: The DAO was called with the correctly transformed vehicle</span>
        verify(exactly = <span class="num">1</span>) { mockVehicleDao.upsertVehicles(listOf(expectedOutput)) }
    }
}
</code></pre>

<hr>

<!-- ==================== SPRING PROFILES ==================== -->
<h2 id="spring-profiles" class="reveal">Spring Profiles</h2>

<p>Spring Profiles control which beans are loaded and which configuration values are used.
Odyssey uses 4 profiles:</p>

<table>
    <tr><th>Profile</th><th>When</th><th>Key Differences</th></tr>
    <tr>
        <td><code>laptop</code></td>
        <td>Local development</td>
        <td>
            <ul>
                <li>MongoDB on localhost:27020</li>
                <li>Azurite blob storage on localhost:10010</li>
                <li>Cron jobs disabled (impossible dates)</li>
                <li>Dummy message senders (just log)</li>
                <li>CORS permissive (all origins)</li>
                <li>BlockHound disabled</li>
                <li>DataDog metrics disabled</li>
                <li>External APIs point to localhost stubs</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>dev</code></td>
        <td>Dev cluster</td>
        <td>Real Azure services, 1 replica, auto-deploy on main</td>
    </tr>
    <tr>
        <td><code>uat</code></td>
        <td>UAT cluster</td>
        <td>Real Azure services, 3 replicas, manual deploy, auto-scale 3-12</td>
    </tr>
    <tr>
        <td><code>prod</code></td>
        <td>Production</td>
        <td>Real Azure services, 3 replicas, manual deploy + change request</td>
    </tr>
</table>

<h3 id="config-classes" class="reveal">Configuration Classes</h3>

<p>Spring Boot binds YAML properties to Kotlin classes using <code>@ConfigurationProperties</code>.
Here are the key config classes:</p>

<pre><code><span class="cmt">// Binds properties under "cosmos:" in application.yml</span>
<span class="ann">@Configuration</span>
<span class="ann">@ConfigurationProperties(prefix = "cosmos")</span>
<span class="kw">class</span> <span class="type">CosmosConfig</span> {
    <span class="kw">lateinit var</span> mongoConnString: <span class="type">String</span>      <span class="cmt">// cosmos.mongo-conn-string in YAML</span>
    <span class="kw">var</span> inventoryDatabaseName = <span class="str">"shopInventory"</span>
}

<span class="cmt">// Binds "cron:" section - note how the suspicious delta threshold</span>
<span class="cmt">// is configurable per environment</span>
<span class="ann">@Configuration</span>
<span class="ann">@ConfigurationProperties(prefix = "cron")</span>
<span class="kw">data class</span> <span class="type">CronConfig</span>(
    <span class="kw">var</span> suspiciousDeltaThreshold: <span class="type">Long</span> = <span class="num">15000</span>  <span class="cmt">// If more than 15K vehicles disappear, abort!</span>
)

<span class="cmt">// Cleanup config with nested class</span>
<span class="ann">@Configuration</span>
<span class="ann">@ConfigurationProperties(prefix = "cleanup")</span>
<span class="kw">class</span> <span class="type">DatabaseCleanupConfig</span> {
    <span class="kw">val</span> tempCollectionCleanup = <span class="type">TempCollectionCleanup</span>()
    <span class="kw">class</span> <span class="type">TempCollectionCleanup</span> {
        <span class="kw">var</span> maxAgeSeconds: <span class="type">Long</span> = <span class="num">60 * 60 * 24 * 7 * 4</span>  <span class="cmt">// 28 days</span>
    }
}

<span class="cmt">// Azure Service Bus config</span>
<span class="ann">@ConfigurationProperties(prefix = "finance-service-bus")</span>
<span class="kw">data class</span> <span class="type">FinanceServiceBusConfig</span>(
    <span class="kw">val</span> connectionString: <span class="type">String</span>,
    <span class="kw">val</span> topicName: <span class="type">String</span>,               <span class="cmt">// "leasing-incentives-topic"</span>
    <span class="kw">val</span> subscriptionName: <span class="type">String</span>,        <span class="cmt">// "lease-consumer-sub"</span>
    <span class="kw">val</span> maximumRetries: <span class="type">Long</span>             <span class="cmt">// 5</span>
)
</code></pre>

<div class="callout callout-success reveal">
    <div class="callout-title">How to read YAML &rarr; Kotlin mapping</div>
    <p>
        YAML keys use kebab-case (<code>mongo-conn-string</code>), Kotlin uses camelCase (<code>mongoConnString</code>).
        Spring automatically converts between them. The <code>prefix</code> in <code>@ConfigurationProperties</code>
        maps to the top-level YAML key. Nested classes map to nested YAML structures.
    </p>
</div>

<hr>

<!-- ==================== API ENDPOINTS ==================== -->
<h2 id="api-endpoints" class="reveal">API Endpoints</h2>

<p>Odyssey exposes two API surfaces: <strong>GraphQL queries</strong> for vehicle search (via the <code>search</code> module)
and <strong>REST + GraphQL mutations</strong> for inventory management (via the <code>routes</code> module).</p>

<h3 id="graphql-queries">GraphQL Queries (search module)</h3>

<div class="mermaid-container reveal">
<div class="mermaid-label">GraphQL Query Surface</div>
<pre class="mermaid">
graph LR
    subgraph Frontend["Driveway.com Frontend"]
        SRP["Search Results Page"]
        VDP["Vehicle Detail Page"]
        AUTO["Autocomplete Bar"]
    end

    subgraph Search["odyssey-search-graphql (/shop-graphql/)"]
        Q1["search()"]
        Q2["getFacets()"]
        Q3["getSearchSuggestions()"]
        Q4["getVehicleByVin()"]
        Q5["getVehicleById()"]
        Q6["getVehiclesById()"]
        Q7["getVehiclesByVin()"]
        Q8["checkAvailabilityOfVin()"]
        Q9["getVehicleImagesById()"]
        Q10["getDirectionForId()"]
    end

    SRP --> Q1
    SRP --> Q2
    AUTO --> Q3
    VDP --> Q4
    VDP --> Q5
    VDP --> Q9
    VDP --> Q10
    SRP --> Q6

    style Q1 fill:#1f6feb,stroke:#58a6ff,color:#fff
    style Q2 fill:#1f6feb,stroke:#58a6ff,color:#fff
    style Q3 fill:#1f6feb,stroke:#58a6ff,color:#fff
    style Q9 fill:#6e40c9,stroke:#bc8cff,color:#fff
</pre>
</div>

<table>
    <tr><th>Query</th><th>Purpose</th><th>Input</th></tr>
    <tr><td><code>search(commonInputs)</code></td><td>Full vehicle search with filters, sorting, pagination</td><td>VehicleCommonInputs (filters, sort, pagination, searchTerm, userLocation)</td></tr>
    <tr><td><code>getFacets(facetFields, commonInputs)</code></td><td>Get facet counts for filter sidebar</td><td>Facet field names + search inputs</td></tr>
    <tr><td><code>getSearchSuggestions(queryString)</code></td><td>Autocomplete suggestions</td><td>Partial search text</td></tr>
    <tr><td><code>getVehicleByVin(vin)</code></td><td>Single vehicle lookup by VIN</td><td>17-character VIN</td></tr>
    <tr><td><code>getVehicleById(id)</code></td><td>Single vehicle lookup by vehicleId</td><td>ObjectId string</td></tr>
    <tr><td><code>getVehiclesById([ids])</code></td><td>Batch vehicle lookup by IDs</td><td>List of vehicleId strings</td></tr>
    <tr><td><code>getVehiclesByVin([vins])</code></td><td>Batch vehicle lookup by VINs</td><td>List of VIN strings</td></tr>
    <tr><td><code>checkAvailabilityOfVin(vin)</code></td><td>Check if vehicle is available for purchase</td><td>VIN string</td></tr>
    <tr><td><code>checkAvailabilityOfVehicleId(id)</code></td><td>Check if vehicle is available for purchase</td><td>vehicleId string</td></tr>
    <tr><td><code>getVehicleImagesById(searchTerm)</code></td><td>Photo gallery (6 sizes via MaxDigital)</td><td>Vehicle identifier</td></tr>
    <tr><td><code>getDirectionForId(id)</code></td><td>ID resolution &mdash; VIN/MaxDigital redirect</td><td>Any vehicle identifier</td></tr>
</table>

<h4>Search Filter Input Types</h4>

<pre><code><span class="type">VehicleCommonInputs</span> {
  sortCriteria: <span class="type">SortCriteria?</span>
  filterInput: <span class="type">Filters?</span>
  paginationInput: <span class="type">PaginationInput?</span>
  searchTerm: <span class="type">String?</span>
  userLocation: <span class="type">UserLocation?</span>
}

<span class="type">Filters</span> {
  leasableOnly: <span class="type">Boolean?</span>
  freeShipping: <span class="type">Boolean?</span>
  makeModelTrims: <span class="type">[MakeModelTrimFilter]?</span>
  vehicleConditions: <span class="type">[VehicleCondition]?</span>     <span class="cmt">// NEW, USED, CPO</span>
  mileageRange: <span class="type">IntRange?</span>
  yearRange: <span class="type">IntRange?</span>
  priceRange: <span class="type">DoubleRange?</span>
  leaseRange: <span class="type">IntRange?</span>
  exteriorColors: <span class="type">[String]?</span>
  interiorColors: <span class="type">[String]?</span>
  bodyStyles: <span class="type">[String]?</span>
  fuelTypes: <span class="type">[String]?</span>
  driveTypes: <span class="type">[String]?</span>
  transmissions: <span class="type">[String]?</span>
  engines: <span class="type">[String]?</span>
}</code></pre>

<h3 id="rest-endpoints">REST Endpoints (routes module)</h3>

<table>
    <tr><th>Method</th><th>Path</th><th>Handler</th><th>Purpose</th></tr>
    <tr><td><span class="badge badge-mono" style="background:#238636">POST</span></td><td><code>/impel/spin-notification</code></td><td>ImpelNotificationHandler</td><td>Process 360 spin notifications from Impel (validates, fetches spin URL, updates vehicle)</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#1f6feb">GET</span></td><td><code>/sink/leasing</code></td><td>LeasingSinkRouter</td><td>Stream new vehicles for leasing (NDJSON with backpressure)</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#1f6feb">GET</span></td><td><code>/search/score-weights</code></td><td>SearchScoreWeightsHandler</td><td>Get search score configurations (by sortType query param)</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#1f6feb">GET</span></td><td><code>/search/score-weights/templates</code></td><td>SearchScoreWeightsHandler</td><td>List available block templates for score weights</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#238636">POST</span></td><td><code>/search/score-weights</code></td><td>SearchScoreWeightsHandler</td><td>Create new search score weight (auto-increments version)</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#238636">POST</span></td><td><code>/search/score-weights/enable</code></td><td>SearchScoreWeightsHandler</td><td>Enable specific score weight version for a sortType</td></tr>
    <tr><td><span class="badge badge-mono" style="background:#da3633">DELETE</span></td><td><code>/search/score-weights</code></td><td>SearchScoreWeightsHandler</td><td>Delete score weight version (cannot delete enabled version)</td></tr>
</table>

<h3 id="graphql-mutations">GraphQL Mutations (routes module)</h3>

<div class="card-grid reveal">
    <div class="card">
        <h4>Availability Mutations</h4>
        <ul>
            <li><code>updateManualSuppressions(vins, suppress)</code> &mdash; Toggle manual suppression for vehicles</li>
            <li><code>updatePurchasePending(vin, pending)</code> &mdash; Update purchase pending status</li>
        </ul>
    </div>
    <div class="card">
        <h4>Category &amp; Feature Mutations</h4>
        <ul>
            <li><code>updateCategories(request)</code> &mdash; Create or update vehicle categories</li>
            <li><code>deleteCategoriesByName(request)</code> &mdash; Delete categories by name</li>
            <li><code>updateFeatures(request)</code> &mdash; Create or update features</li>
            <li><code>deleteFeaturesByName(request)</code> &mdash; Delete features by name</li>
        </ul>
    </div>
    <div class="card">
        <h4>Test Mutations (dev/laptop only)</h4>
        <ul>
            <li><code>inputTestVehicle(vehicleRequest)</code> &mdash; Add vehicle to vehicleTest collection</li>
            <li><code>createTestVehicle(vin)</code> &mdash; Create test vehicle by VIN</li>
            <li><code>deleteTestVehicle(vin)</code> &mdash; Delete test vehicle</li>
            <li><code>dumpTestVehicleCollection()</code> &mdash; Drop entire vehicleTest collection</li>
        </ul>
    </div>
    <div class="card">
        <h4>Admin Queries (routes module)</h4>
        <ul>
            <li><code>getManualSuppressions()</code> &mdash; List manually suppressed active vehicles</li>
            <li><code>getPurchasePendings()</code> &mdash; List purchase-pending active vehicles</li>
            <li><code>getAllCategories()</code> &mdash; Get all categories sorted by sortOrder</li>
            <li><code>getAllFeatures(page?)</code> &mdash; Get all features with optional pagination</li>
        </ul>
    </div>
</div>

<h3 id="search-scoring">Search Scoring System</h3>

<div class="callout callout-info reveal">
    <div class="callout-title">Configuration-Driven Ranking</div>
    <p>
        Search results are scored using MongoDB Atlas Search with <strong>versioned score weights</strong>
        stored in the <code>searchScoreWeights</code> collection. Each sort type (RECOMMENDED, PRICE_LOWEST, etc.)
        has customizable scoring factors that can be updated via the REST API without redeploying.
    </p>
</div>

<table>
    <tr><th>Scoring Factor</th><th>Type</th><th>Example (RECOMMENDED sort)</th></tr>
    <tr><td>Text match weights</td><td>TextBlock</td><td>make: 10000, model: 10000, bodyStyle: 10000</td></tr>
    <tr><td>Days in stock proximity</td><td>NearBlock</td><td>origin=5, pivot=30 (newer inventory boosted)</td></tr>
    <tr><td>Financeable vehicle</td><td>Static</td><td>+10 bonus</td></tr>
    <tr><td>360 spin photo</td><td>Static</td><td>+60 bonus</td></tr>
    <tr><td>Good availability</td><td>Static</td><td>+10000 (no purchase pending, no suppression)</td></tr>
    <tr><td>Condition + low mileage</td><td>Compound</td><td>+560</td></tr>
    <tr><td>Free shipping eligible</td><td>Static</td><td>+130</td></tr>
    <tr><td>Gauss scoring</td><td>NearBlock</td><td>Normal distribution curves for price/mileage/year</td></tr>
</table>

<hr>

<!-- ==================== DATA MODELS ==================== -->
<h2 id="data-models" class="reveal">Data Models</h2>

<h3 id="vehicle-model">Core Domain Model: Vehicle</h3>

<p>The <code>Vehicle</code> data class is the central entity in the system. VIN serves as the primary key (<code>@BsonId</code>).
Collection: <code>vehicleV3</code> in <code>shopInventory</code> database.</p>

<div class="mermaid-container reveal">
<div class="mermaid-label">Vehicle Model Structure</div>
<pre class="mermaid">
classDiagram
    class Vehicle {
        +String vin &lt;&lt;BsonId&gt;&gt;
        +String? vehicleId
        +InventoryStatus? status
        +Boolean manuallySuppressed
        +Ymmt? ymmt
        +VehicleCondition? vehicleCondition
        +Double? price
        +Int? priceInCents
        +Double? msrp
        +Leasing? leasing
        +Availability? availability
        +Int? mileage
        +String? bodyStyle
        +Image? image
        +Dealer? dealer
        +Hints? hints
        +toDelta(action) InventoryDelta
    }
    class Ymmt {
        +Int? year
        +String? make
        +String? model
        +String? trim
    }
    class Leasing {
        +Boolean? canLease
        +Int? defaultPrice
        +List~RegionData~? regionalPrices
    }
    class RegionData {
        +Int? regionId
        +Int? amountInCents
        +String? expiresOn
    }
    class Availability {
        +Boolean purchasePending
        +Boolean salesPending
        +Boolean salesBooked
        +Boolean inventoryInTransit
        +Boolean reconOrderOpen
        +Instant? enqueuedTime
    }
    class Dealer {
        +String? id
        +String? name
        +String? state
        +String? zip
        +Int? region
        +List~String~? zoneZips
        +Map? stateShippingMap
    }
    class Image {
        +String? heroUrl
        +String? spinUrl
        +Int? count
    }

    Vehicle --> Ymmt
    Vehicle --> Leasing
    Vehicle --> Availability
    Vehicle --> Dealer
    Vehicle --> Image
    Leasing --> RegionData
</pre>
</div>

<pre><code><span class="cmt">// Key Vehicle fields grouped by domain</span>

<span class="cmt">// Identity</span>
vin: <span class="type">String</span>              <span class="cmt">// @BsonId — primary key</span>
vehicleId: <span class="type">String?</span>       <span class="cmt">// Secondary ID (ObjectId)</span>

<span class="cmt">// Status</span>
status: <span class="type">InventoryStatus?</span> <span class="cmt">// ACTIVE, INACTIVE, DELETED</span>
manuallySuppressed: <span class="type">Boolean</span>
financeable: <span class="type">Boolean</span>

<span class="cmt">// Vehicle Info</span>
ymmt: <span class="type">Ymmt?</span>             <span class="cmt">// { year, make, model, trim }</span>
vehicleCondition: <span class="type">VehicleCondition?</span> <span class="cmt">// NEW, USED, CPO, UNKNOWN</span>
bodyStyle: <span class="type">String?</span>
makeModel: <span class="type">String?</span>       <span class="cmt">// Concatenated make+model for search</span>

<span class="cmt">// Pricing</span>
price: <span class="type">Double?</span>           msrp: <span class="type">Double?</span>
priceInCents: <span class="type">Int?</span>      drivewayPrice: <span class="type">Double?</span>
askingPrice: <span class="type">Double?</span>     dealerInvoicePrice: <span class="type">Double?</span>

<span class="cmt">// Specs</span>
mileage: <span class="type">Int?</span>   engine: <span class="type">String?</span>   fuel: <span class="type">String?</span>   transmission: <span class="type">String?</span>
driveType: <span class="type">String?</span>   doors: <span class="type">Int?</span>   mpg: <span class="type">Mpg?</span> { combined, city, highway }

<span class="cmt">// Colors</span>
exteriorColor: <span class="type">Color?</span> { name, descriptive }
interiorColor: <span class="type">Color?</span> { name, descriptive }

<span class="cmt">// Media</span>
image: <span class="type">Image?</span> { heroUrl, spinUrl, count }

<span class="cmt">// Computed (not persisted — @BsonIgnore)</span>
score: <span class="type">Double</span>            <span class="cmt">// From $search aggregations</span>
shippingFee: <span class="type">Double?</span>     <span class="cmt">// Calculated at query time</span>
sortField: <span class="type">Any?</span>         <span class="cmt">// For custom sort projections</span></code></pre>

<h3 id="mongo-collections">MongoDB Collections</h3>

<table>
    <tr><th>Collection</th><th>Purpose</th><th>Key Indexes</th></tr>
    <tr><td><strong>vehicleV3</strong></td><td>Live inventory (primary)</td><td>22+ indexes: status+suppressed, price, year, make+model, VIN, dealer.id, dealer.state, leasing.canLease, availability, bodyStyle, vehicleCondition, mileage, daysInStock</td></tr>
    <tr><td><strong>temp_vehicleV3_*</strong></td><td>Staging for EDS imports (auto-dropped)</td><td>None (temporary)</td></tr>
    <tr><td><strong>searchSuggestion</strong></td><td>Autocomplete data</td><td>Unique on <code>value</code></td></tr>
    <tr><td><strong>postalCodeOemRegions</strong></td><td>Postal code &rarr; OEM region mapping</td><td><code>postalCode</code> (@BsonId)</td></tr>
    <tr><td><strong>searchScoreWeights</strong></td><td>Versioned search ranking configs per SortType</td><td>Unique on (<code>sortType</code>, <code>version</code>)</td></tr>
    <tr><td><strong>inventoryJobDetails</strong></td><td>Import job history and status</td><td><code>runId</code> (@Id)</td></tr>
    <tr><td><strong>vehicleTest</strong></td><td>Functional test vehicles (dev/laptop only)</td><td>None</td></tr>
    <tr><td><strong>vehicleSearchRelevancyTest</strong></td><td>Search relevancy test data</td><td>None</td></tr>
</table>

<h3 id="atlas-search">Atlas Search Indexes</h3>

<p>Managed via Terraform. <strong>Local MongoDB Community does NOT support Atlas Search</strong> &mdash; search queries will fail locally.</p>

<table>
    <tr><th>Index Name</th><th>Collection</th><th>Type</th><th>Key Fields</th></tr>
    <tr><td><strong>shopSearch</strong></td><td>vehicleV3</td><td>Full-text + facets</td><td>50+ mapped fields: ymmt (year/make/model/trim with facets), bodyStyle, makeModel (autocomplete), price, mileage, leasing (embeddedDocuments), dealer, vehicleCondition (stringFacet), availability, image, categoryFeatures</td></tr>
    <tr><td><strong>shopSuggestions</strong></td><td>searchSuggestion</td><td>Autocomplete</td><td><code>value</code> field with lucene.standard analyzer</td></tr>
</table>

<h3 id="key-enums">Key Enums</h3>

<div class="card-grid reveal">
    <div class="card">
        <h4>VehicleCondition</h4>
        <ul>
            <li><code>NEW</code></li>
            <li><code>USED</code></li>
            <li><code>CPO</code> (Certified Pre-Owned)</li>
            <li><code>UNKNOWN</code></li>
        </ul>
    </div>
    <div class="card">
        <h4>InventoryStatus</h4>
        <ul>
            <li><code>ACTIVE</code></li>
            <li><code>INACTIVE</code></li>
            <li><code>DELETED</code></li>
        </ul>
    </div>
    <div class="card">
        <h4>SortType</h4>
        <ul>
            <li><code>RECOMMENDED</code></li>
            <li><code>HIGH_PRICE_NEW_CAR</code> / <code>USED_CAR</code></li>
            <li><code>LOW_PRICE_NEW_CAR</code> / <code>USED_CAR</code></li>
            <li><code>SHIPPING_FEE_LOWEST</code></li>
            <li><code>INVENTORY_NEWEST</code></li>
            <li><code>LOWEST_MILEAGE</code></li>
            <li><code>NEWEST_YEAR</code> / <code>OLDEST_YEAR</code></li>
            <li><code>LEASING_LOWEST</code></li>
        </ul>
    </div>
    <div class="card">
        <h4>JobStatus</h4>
        <ul>
            <li><code>RUNNING</code> / <code>SUCCEEDED</code> / <code>FAILED</code></li>
            <li><code>CANCELLED</code> / <code>KILLED</code></li>
            <li><code>ALREADY_RUNNING</code></li>
            <li><code>SUSPICIOUS_FILE</code></li>
            <li><code>INVALID_DOCUMENT</code></li>
        </ul>
    </div>
    <div class="card">
        <h4>InventoryDeltaAction</h4>
        <ul>
            <li><code>ADD</code> &mdash; new vehicle appeared</li>
            <li><code>UPDATE</code> &mdash; price or mileage changed</li>
            <li><code>DELETE</code> &mdash; vehicle left inventory</li>
        </ul>
    </div>
    <div class="card">
        <h4>ImportType / ImportRunner</h4>
        <ul>
            <li>ImportType: <code>FULL</code>, <code>DELTA</code>, <code>UNKNOWN</code></li>
            <li>ImportRunner: <code>READ_BLOBS</code>, <code>READ_VEHICLES</code>, <code>READ_EDS_VEHICLES</code>, <code>READ_SEARCH_TEST_VEHICLES</code></li>
        </ul>
    </div>
</div>

<hr>

<!-- ==================== DEPLOYMENT ==================== -->
<h2 id="deployment" class="reveal">Deployment &amp; CI/CD</h2>

<h3 id="environments">Environments</h3>

<table>
    <tr><th>Environment</th><th>Trigger</th><th>Replicas</th><th>Auto-Scale</th><th>AKS Cluster</th></tr>
    <tr><td><strong>DEV</strong></td><td>Auto (main branch)</td><td>1</td><td>Disabled</td><td>AKS westus2</td></tr>
    <tr><td><strong>UAT</strong></td><td>Manual</td><td>3</td><td>3&ndash;12 @ 70% CPU</td><td>AKS westus2</td></tr>
    <tr><td><strong>PROD</strong></td><td>Manual + Change Request</td><td>3</td><td>3&ndash;12 @ 70% CPU</td><td>AKS westus2</td></tr>
    <tr><td><strong>LAPTOP</strong></td><td>Local dev</td><td>1</td><td>N/A</td><td>Docker Compose</td></tr>
</table>

<h3 id="cicd-pipeline">CI/CD Pipeline</h3>

<div class="mermaid-container reveal">
<div class="mermaid-label">Build &amp; Deploy Pipeline</div>
<pre class="mermaid">
graph LR
    BUILD["1. Build<br/>Gradle clean build"] --> TEST["2. Test<br/>JUnit 5 + MockK"]
    TEST --> COVER["3. Coverage<br/>Kover report"]
    COVER --> LINT["4. Lint<br/>Kotlinter check"]
    LINT --> DOCKER["5. Docker<br/>Multi-stage build<br/>+ DataDog agent"]
    DOCKER --> TF["6. Terraform<br/>MongoDB indexes<br/>Service Bus topics"]
    TF --> HELM["7. Helm Deploy<br/>5 services to AKS"]
    HELM --> SMOKE["8. Smoke Tests<br/>Post-deploy validation"]
    SMOKE --> POSTMAN["9. Postman Tests<br/>Functional API tests"]

    style BUILD fill:#1f6feb,stroke:#58a6ff,color:#fff
    style TEST fill:#1f6feb,stroke:#58a6ff,color:#fff
    style COVER fill:#1f6feb,stroke:#58a6ff,color:#fff
    style LINT fill:#1f6feb,stroke:#58a6ff,color:#fff
    style DOCKER fill:#6e40c9,stroke:#bc8cff,color:#fff
    style TF fill:#d29922,stroke:#e3b341,color:#000
    style HELM fill:#238636,stroke:#3fb950,color:#fff
    style SMOKE fill:#238636,stroke:#3fb950,color:#fff
    style POSTMAN fill:#238636,stroke:#3fb950,color:#fff
</pre>
</div>

<h3 id="deployed-services">Deployed Services</h3>

<table>
    <tr><th>Service</th><th>Helm Chart</th><th>Endpoint</th><th>Module</th><th>Resources</th></tr>
    <tr><td><strong>odyssey-api</strong></td><td>api (v5)</td><td><code>/shop/</code></td><td>routes</td><td>1 CPU, 1Gi RAM</td></tr>
    <tr><td><strong>odyssey-search-graphql</strong></td><td>api (v5)</td><td><code>/shop-graphql/</code></td><td>search</td><td>1 CPU, 1Gi RAM</td></tr>
    <tr><td><strong>odyssey-consumer</strong></td><td>headless (v5)</td><td><code>/shop-consumer/</code></td><td>consumer</td><td>1 CPU, 1Gi RAM</td></tr>
    <tr><td><strong>odyssey-availability-sub</strong></td><td>headless (v5)</td><td><code>/shop-availability-sub/</code></td><td>availability</td><td>1 CPU, 1Gi RAM</td></tr>
    <tr><td><strong>odyssey-cron</strong></td><td>cron (v5)</td><td>N/A (background)</td><td>cron</td><td>1 CPU, 4Gi RAM</td></tr>
</table>

<h3 id="docker-build">Docker Multi-Stage Build</h3>

<pre><code><span class="cmt"># Stage 1: Builder</span>
FROM gradle:jdk21 <span class="kw">as</span> builder
COPY . /home/gradle
WORKDIR /home/gradle/${PROJECT}
RUN ../gradlew bootjar --parallel
RUN wget -O dd-java-agent.jar <span class="str">'https://dtdg.co/latest-java-tracer'</span>

<span class="cmt"># Stage 2: Runtime</span>
FROM ${REGISTRY_URL}/devops/eclipse-temurin-21:latest
COPY --from=builder /home/gradle/${PROJECT}/build/libs/${PROJECT}-1.0.0.jar .
COPY --from=builder /home/gradle/${PROJECT}/dd-java-agent.jar .
EXPOSE <span class="num">8080</span>
ENTRYPOINT java -XX:MaxRAMPercentage=<span class="num">75.0</span> -javaagent:dd-java-agent.jar -jar ${PROJECT}.jar</code></pre>

<h3 id="iac">Infrastructure as Code</h3>

<div class="card-grid reveal">
    <div class="card">
        <h4>Terraform Modules</h4>
        <ul>
            <li><strong>MongoDB Atlas Search:</strong> shopSearch (50+ fields), shopSuggestions</li>
            <li><strong>Service Bus:</strong> 4 topics with subscriptions, TTLs, lock durations</li>
            <li><strong>Monitoring:</strong> Azure Monitor alerts, dashboards</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Paths: <code>terraform/infrastructure/{dev,uat,prod}/</code></p>
    </div>
    <div class="card">
        <h4>Azure Resources</h4>
        <ul>
            <li><strong>Service Bus:</strong> inventory-delta (P14D TTL), leasing-incentives (P2D TTL), cart-status-update, vehicle-data (PT15M TTL)</li>
            <li><strong>Blob Storage:</strong> container: inbound, prefix: CVP/Driveway-Merchandising-V2/</li>
            <li><strong>Key Vaults:</strong> 5 vaults per environment</li>
            <li><strong>DataDog:</strong> APM via dd-java-agent</li>
        </ul>
    </div>
</div>

<hr>

<!-- ==================== EXTERNAL INTEGRATIONS ==================== -->
<h2 id="ext-integrations" class="reveal">External Integrations</h2>

<div class="mermaid-container reveal">
<div class="mermaid-label">External Integration Map</div>
<pre class="mermaid">
graph TB
    subgraph Odyssey["Odyssey Services"]
        CRON["odyssey-cron"]
        SEARCH["odyssey-search-graphql"]
        ROUTES["odyssey-api"]
        CONSUMER["odyssey-consumer"]
        AVAIL["odyssey-availability-sub"]
    end

    subgraph External["Third-Party APIs"]
        MAXD["MaxDigital<br/>api.maxapps.io/graphql<br/>(Vehicle Photos)"]
        IMPEL["Impel/SpinCar<br/>wa-detection-api.spincar.com<br/>(360 Spins)"]
    end

    subgraph Internal["Internal Lithia Services"]
        LIBRA["Libra API<br/>admin-api/v5<br/>(Dealerships, Zones)"]
        INCENT["Incentives API<br/>incentives-api/v1<br/>(OEM Regions)"]
        TAXFEE["Tax &amp; Fee API<br/>taxes-fees-api/v1<br/>(Shipping Costs)"]
    end

    subgraph Azure["Azure Cloud"]
        BLOB["Azure Blob Storage<br/>EDS TSV Files"]
        SB["Azure Service Bus<br/>4 Topics"]
        KV["Azure Key Vault<br/>Secrets"]
    end

    SEARCH -->|"GraphQL: GetGalleryImages"| MAXD
    ROUTES -->|"REST: Spin URL by VIN"| IMPEL
    CRON -->|"REST: Dealerships, Zones"| LIBRA
    CRON -->|"REST: OEM Regions"| INCENT
    CRON -->|"REST: Shipping Config"| TAXFEE
    CRON -->|"Download GZIP TSV"| BLOB
    CRON -->|"Publish deltas"| SB
    CONSUMER -->|"Subscribe leasing"| SB
    AVAIL -->|"Subscribe cart status"| SB

    style MAXD fill:#6e40c9,stroke:#bc8cff,color:#fff
    style IMPEL fill:#6e40c9,stroke:#bc8cff,color:#fff
    style LIBRA fill:#1f6feb,stroke:#58a6ff,color:#fff
    style INCENT fill:#1f6feb,stroke:#58a6ff,color:#fff
    style TAXFEE fill:#1f6feb,stroke:#58a6ff,color:#fff
</pre>
</div>

<h3 id="internal-services">Internal Lithia Services</h3>

<div class="card-grid reveal">
    <div class="card">
        <h4>Libra API</h4>
        <p>Endpoint: <code>admin-api/v5</code></p>
        <p>Client: <code>LibraClient</code></p>
        <ul>
            <li>GET /dealerships?activity=ZERO_DOLLAR_SHIPPING</li>
            <li>GET /zones (free shipping zip codes)</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Used by cron during EDS import to enrich dealer data.</p>
    </div>
    <div class="card">
        <h4>Incentives API</h4>
        <p>Endpoint: <code>incentives-api.marketplace/v1</code></p>
        <p>Client: <code>IncentivesClient</code></p>
        <ul>
            <li>GET /regions (postal code &rarr; OEM regions)</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Synced 4x daily by cron to postalCodeOemRegions collection.</p>
    </div>
    <div class="card">
        <h4>Tax &amp; Fee API</h4>
        <p>Endpoint: <code>taxes-fees-api/v1</code></p>
        <p>Client: <code>TaxAndFeeClient</code></p>
        <ul>
            <li>GET /shipping-config (state-to-state shipping cost matrix)</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Called during EDS import to enrich shipping fees.</p>
    </div>
</div>

<h3 id="thirdparty-services">Third-Party Services</h3>

<div class="card-grid reveal">
    <div class="card">
        <h4>MaxDigital (Photos)</h4>
        <p>Endpoint: <code>https://api.maxapps.io/graphql</code></p>
        <p>Protocol: GraphQL | Auth: X-API-Key header</p>
        <ul>
            <li>Query: <code>GetGalleryImages(syndicationId)</code></li>
            <li>Returns 6 image sizes: icon, thumb, medium, large, gallery, raw</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Called on-demand by search module for image gallery queries.</p>
    </div>
    <div class="card">
        <h4>Impel / SpinCar (360 Views)</h4>
        <p>Endpoint: <code>https://wa-detection-api.spincar.com</code></p>
        <p>Protocol: REST | Auth: SHA-512 hash</p>
        <ul>
            <li>Fetches 360-degree spin URLs by VIN</li>
            <li>5 retries with exponential backoff</li>
        </ul>
        <p style="color: var(--text-muted); font-size: 12px;">Triggered by POST /impel/spin-notification webhooks.</p>
    </div>
</div>

<h3 id="message-consumers">Message Consumer Details</h3>

<table>
    <tr><th>Consumer</th><th>Topic / Subscription</th><th>Message Type</th><th>Processing</th></tr>
    <tr>
        <td><strong>odyssey-consumer</strong><br/><span style="color: var(--text-muted); font-size: 12px;">LeaseTopicReceiver</span></td>
        <td><code>leasing-incentives-topic</code><br/><span style="color: var(--text-muted); font-size: 12px;">sub: lease-consumer-sub<br/>TTL: P2D, Lock: PT5M, Retries: 5</span></td>
        <td>LeaseIncentivesMessage<br/>(LEASING or INCENTIVE)</td>
        <td><strong>LEASING:</strong> Fetches vehicle, creates Leasing object with sorted regional prices, sets canLease (NEW vehicles only).<br/><strong>INCENTIVE:</strong> No-op (logs warning).</td>
    </tr>
    <tr>
        <td><strong>odyssey-availability-sub</strong><br/><span style="color: var(--text-muted); font-size: 12px;">CartTopicConsumerStarter</span></td>
        <td><code>cart-status-update-topic</code><br/><span style="color: var(--text-muted); font-size: 12px;">sub: vehicle-availability-subscriber-sub<br/>Max retries: 60</span></td>
        <td>CartStatusUpdateMessage</td>
        <td>Validates message recency (enqueuedTime &gt; vehicle's last). Stale messages acknowledged without processing. Missing vehicles return Success (no retry).</td>
    </tr>
    <tr>
        <td><strong>External (F&amp;I)</strong></td>
        <td><code>inventory-delta-topic</code><br/><span style="color: var(--text-muted); font-size: 12px;">TTL: P14D (14 days)</span></td>
        <td>InventoryDelta</td>
        <td>Published by cron during import. Contains ADD/UPDATE/DELETE actions. Chunked to fit 256KB per-message limit.</td>
    </tr>
</table>

<hr>

<h2>Quick Reference: Running Commands</h2>

<pre><code><span class="cmt"># Build everything</span>
./gradlew clean build

<span class="cmt"># Run tests + lint + coverage</span>
./gradlew clean verify

<span class="cmt"># Run tests for one module</span>
./gradlew :library:test
./gradlew :cron:test
./gradlew :search:test

<span class="cmt"># Run a single test class</span>
./gradlew :cron:test --tests <span class="str">"com.lithia.odyssey.cron.components.CronLeasingTest"</span>

<span class="cmt"># Fix lint issues</span>
./gradlew formatKotlin

<span class="cmt"># Start local dependencies (MongoDB + Azurite)</span>
docker compose up -d

<span class="cmt"># Run a service locally</span>
./gradlew clean :search:bootRun --args=<span class="str">'--spring.profiles.active=laptop'</span>
</code></pre>

<hr>

<p style="text-align: center; color: var(--text-muted); padding: 30px 0;">
    Generated for the Odyssey-Api team &mdash; Driveway.com
</p>

</main>

<script>
// ===== 1. SCROLL REVEAL (IntersectionObserver) =====
// Elements with .reveal class fade in as they enter the viewport
// This creates progressive disclosure - you learn one concept at a time
(function initScrollReveal() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
            }
        });
    }, {
        threshold: 0.08,
        rootMargin: '0px 0px -40px 0px'
    });

    // Observe all revealable elements
    document.querySelectorAll('.reveal, .reveal-stagger').forEach(el => observer.observe(el));

    // Also auto-apply reveal to all pre (code blocks) and standalone tables
    document.querySelectorAll('pre, table').forEach(el => {
        if (!el.closest('.pipeline-demo') && !el.closest('.lifecycle-demo') && !el.closest('.eds-pipeline') && !el.closest('.comparison-container')) {
            el.classList.add('reveal');
            observer.observe(el);
        }
    });

    // Also reveal paragraphs that follow h2/h3 and hr elements
    document.querySelectorAll('hr').forEach(el => {
        el.classList.add('reveal');
        observer.observe(el);
    });
})();

// ===== 2. READING PROGRESS BAR =====
// Shows how far through the document you've read
(function initProgressBar() {
    const bar = document.getElementById('progressBar');
    if (!bar) return;

    let ticking = false;
    window.addEventListener('scroll', () => {
        if (!ticking) {
            requestAnimationFrame(() => {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const progress = Math.min((scrollTop / docHeight) * 100, 100);
                bar.style.width = progress + '%';
                ticking = false;
            });
            ticking = true;
        }
    });
})();

// ===== 3. ACTIVE SIDEBAR TRACKING =====
// Highlights the current section in the sidebar as you scroll
(function initSidebarTracking() {
    const sections = document.querySelectorAll('[id]');
    const navLinks = document.querySelectorAll('nav ul li a');
    const chapterIndicator = document.getElementById('chapterIndicator');
    const chapterName = document.getElementById('chapterName');

    // Build a map of section ids to their top positions
    let sectionPositions = [];
    function updatePositions() {
        sectionPositions = [];
        sections.forEach(section => {
            if (section.tagName.match(/^H[1-3]$/)) {
                sectionPositions.push({
                    id: section.id,
                    top: section.getBoundingClientRect().top + window.scrollY - 80,
                    text: section.textContent.trim()
                });
            }
        });
    }
    updatePositions();
    window.addEventListener('resize', updatePositions);

    let lastActive = null;
    let hideTimeout = null;

    window.addEventListener('scroll', () => {
        const scrollY = window.scrollY;
        let current = '';
        let currentText = '';

        for (let i = sectionPositions.length - 1; i >= 0; i--) {
            if (scrollY >= sectionPositions[i].top) {
                current = sectionPositions[i].id;
                currentText = sectionPositions[i].text;
                break;
            }
        }

        if (current !== lastActive) {
            lastActive = current;

            // Update nav links
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });

            // Show chapter indicator briefly
            if (chapterIndicator && chapterName && currentText) {
                chapterName.textContent = currentText;
                chapterIndicator.classList.add('show');
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    chapterIndicator.classList.remove('show');
                }, 2000);
            }
        }
    });
})();

// ===== 4. INTERACTIVE MONO LIFECYCLE VISUALIZER =====
function runMonoLifecycle(scenario) {
    // Reset all states
    const ids = ['lc-subscribe', 'lc-onnext', 'lc-complete', 'lc-line1', 'lc-line2', 'lc-particle1', 'lc-particle2'];
    const labels = ['lc-subscribe-label', 'lc-onnext-label', 'lc-complete-label'];
    ids.forEach(id => {
        const el = document.getElementById(id);
        el.classList.remove('active', 'success', 'error', 'moving');
    });
    labels.forEach(id => {
        const el = document.getElementById(id);
        el.classList.remove('active', 'success', 'error');
    });

    const explanation = document.getElementById('monoExplanation');
    const onNextCircle = document.getElementById('lc-onnext');
    const onNextLabel = document.getElementById('lc-onnext-label');
    const completeCircle = document.getElementById('lc-complete');
    const completeLabel = document.getElementById('lc-complete-label');

    // Step 1: Subscribe activates (immediate)
    setTimeout(() => {
        document.getElementById('lc-subscribe').classList.add('active');
        document.getElementById('lc-subscribe-label').classList.add('active');
        explanation.innerHTML = '<strong style="color:var(--accent)">Step 1:</strong> .subscribe() is called. The reactive pipeline starts executing. Nothing happens until this moment.';
    }, 200);

    // Step 2: Data particle moves along line 1
    setTimeout(() => {
        document.getElementById('lc-line1').classList.add('active');
        document.getElementById('lc-particle1').classList.add('moving');
        explanation.innerHTML = '<strong style="color:var(--accent)">Step 2:</strong> The subscription signal travels upstream, then data flows downstream through the operators...';
    }, 900);

    // Step 3: onNext or onError fires
    setTimeout(() => {
        if (scenario === 'success') {
            onNextCircle.textContent = 'V';
            onNextCircle.classList.add('success');
            onNextLabel.textContent = 'onNext(Vehicle)';
            onNextLabel.classList.add('success');
            explanation.innerHTML = '<strong style="color:var(--accent-green)">Step 3 - Success:</strong> The Mono emits a value via <code>onNext(vehicle)</code>. Your .map() / .flatMap() operators receive this value.';
        } else if (scenario === 'empty') {
            onNextCircle.textContent = '0';
            onNextCircle.classList.add('active');
            onNextLabel.textContent = 'no onNext';
            onNextLabel.classList.add('active');
            explanation.innerHTML = '<strong style="color:var(--accent)">Step 3 - Empty:</strong> No onNext signal is emitted. The Mono completes without a value. <code>.switchIfEmpty()</code> operators react to this.';
        } else {
            onNextCircle.textContent = '!';
            onNextCircle.classList.add('error');
            onNextLabel.textContent = 'onError(Exception)';
            onNextLabel.classList.add('error');
            explanation.innerHTML = '<strong style="color:var(--accent-red)">Step 3 - Error:</strong> An error signal is emitted via <code>onError(e)</code>. <code>.onErrorResume()</code> or <code>.onErrorMap()</code> operators handle this.';
        }
    }, 1800);

    // Step 4: Data particle moves along line 2
    setTimeout(() => {
        const cls = scenario === 'success' ? 'success' : scenario === 'error' ? 'error' : 'active';
        document.getElementById('lc-line2').classList.add(cls);
        document.getElementById('lc-particle2').classList.add('moving');
    }, 2500);

    // Step 5: onComplete fires
    setTimeout(() => {
        if (scenario === 'error') {
            completeCircle.textContent = 'X';
            completeCircle.classList.add('error');
            completeLabel.textContent = 'terminated';
            completeLabel.classList.add('error');
            explanation.innerHTML = '<strong style="color:var(--accent-red)">Step 4:</strong> The pipeline terminates with an error. <code>.doFinally()</code> runs for cleanup. In JS terms: the Promise rejects.';
        } else {
            completeCircle.classList.add('success');
            completeLabel.textContent = 'onComplete';
            completeLabel.classList.add('success');
            if (scenario === 'success') {
                explanation.innerHTML = '<strong style="color:var(--accent-green)">Step 4:</strong> The Mono signals <code>onComplete</code>. The pipeline is done. <code>.doOnSuccess()</code> and <code>.doFinally()</code> run. In JS terms: the Promise resolves.';
            } else {
                explanation.innerHTML = '<strong style="color:var(--accent-green)">Step 4:</strong> The Mono signals <code>onComplete</code> without any value. Like <code>Promise.resolve(undefined)</code>. Use <code>.switchIfEmpty()</code> to provide a fallback.';
            }
        }
    }, 3200);
}

// ===== 5. INTERACTIVE REACTIVE PIPELINE DEMO =====
let pipelineRunning = false;

function runReactivePipeline() {
    if (pipelineRunning) return;
    pipelineRunning = true;

    const btn = document.getElementById('runPipeline');
    btn.disabled = true;

    // Reset everything
    ['dt-input', 'dt-filter', 'dt-map', 'dt-take'].forEach(id => {
        document.getElementById(id).innerHTML = '';
    });
    ['ps-source', 'ps-filter', 'ps-map', 'ps-take', 'ps-subscribe'].forEach(id => {
        document.getElementById(id).classList.remove('active', 'done');
    });
    ['pa-1', 'pa-2', 'pa-3', 'pa-4'].forEach(id => {
        document.getElementById(id).classList.remove('active', 'done');
    });

    const explanation = document.getElementById('pipeExplanation');
    const inputData = [1, 2, 3, 4, 5, 6];
    const filteredData = inputData.filter(x => x > 2); // [3, 4, 5, 6]
    const mappedData = filteredData.map(x => x * 10);   // [30, 40, 50, 60]
    const takenData = mappedData.slice(0, 3);            // [30, 40, 50]

    function createDataItem(val, type, delay) {
        const el = document.createElement('span');
        el.className = 'data-item ' + type;
        el.textContent = val;
        el.style.animationDelay = delay + 'ms';
        el.classList.add('new-val');
        return el;
    }

    // Stage 1: Source emits all values
    setTimeout(() => {
        document.getElementById('ps-source').classList.add('active');
        explanation.innerHTML = '<strong style="color:var(--accent)">Flux.just(1, 2, 3, 4, 5, 6)</strong> &mdash; Creates a Flux that will emit these 6 values. Like <code>Observable.of(1,2,3,4,5,6)</code> in RxJS.';
        inputData.forEach((val, i) => {
            setTimeout(() => {
                document.getElementById('dt-input').appendChild(createDataItem(val, 'num', 0));
            }, i * 120);
        });
    }, 300);

    // Stage 2: Filter
    setTimeout(() => {
        document.getElementById('ps-source').classList.remove('active');
        document.getElementById('ps-source').classList.add('done');
        document.getElementById('pa-1').classList.add('done');
        document.getElementById('ps-filter').classList.add('active');
        explanation.innerHTML = '<strong style="color:var(--accent)">.filter(x &gt; 2)</strong> &mdash; Only items passing the predicate continue downstream. Items 1 and 2 are dropped. Like <code>.pipe(filter(x => x > 2))</code> in RxJS.';

        inputData.forEach((val, i) => {
            setTimeout(() => {
                if (val > 2) {
                    document.getElementById('dt-filter').appendChild(createDataItem(val, 'num', 0));
                }
                // Mark filtered items in input
                const inputItems = document.getElementById('dt-input').children;
                if (val <= 2 && inputItems[i]) {
                    inputItems[i].classList.add('filtered');
                }
            }, i * 150);
        });
    }, 1500);

    // Stage 3: Map
    setTimeout(() => {
        document.getElementById('ps-filter').classList.remove('active');
        document.getElementById('ps-filter').classList.add('done');
        document.getElementById('pa-2').classList.add('done');
        document.getElementById('ps-map').classList.add('active');
        explanation.innerHTML = '<strong style="color:var(--accent)">.map(x * 10)</strong> &mdash; Transform each value. This is synchronous (unlike flatMap). Each item becomes 10x its value. Like <code>.pipe(map(x => x * 10))</code>.';

        filteredData.forEach((val, i) => {
            setTimeout(() => {
                document.getElementById('dt-map').appendChild(createDataItem(val * 10, 'str', 0));
            }, i * 150);
        });
    }, 3000);

    // Stage 4: Take
    setTimeout(() => {
        document.getElementById('ps-map').classList.remove('active');
        document.getElementById('ps-map').classList.add('done');
        document.getElementById('pa-3').classList.add('done');
        document.getElementById('ps-take').classList.add('active');
        explanation.innerHTML = '<strong style="color:var(--accent)">.take(3)</strong> &mdash; Takes only the first 3 items then <strong>cancels</strong> the upstream. Value 60 never reaches the subscriber. Like <code>.pipe(take(3))</code>.';

        takenData.forEach((val, i) => {
            setTimeout(() => {
                document.getElementById('dt-take').appendChild(createDataItem(val, 'obj', 0));
            }, i * 150);
        });

        // Mark the 4th mapped item as filtered
        setTimeout(() => {
            const mapItems = document.getElementById('dt-map').children;
            if (mapItems[3]) mapItems[3].classList.add('filtered');
        }, 500);
    }, 4300);

    // Stage 5: Complete
    setTimeout(() => {
        document.getElementById('ps-take').classList.remove('active');
        document.getElementById('ps-take').classList.add('done');
        document.getElementById('pa-4').classList.add('done');
        document.getElementById('ps-subscribe').classList.add('done');
        explanation.innerHTML = '<strong style="color:var(--accent-green)">Complete!</strong> The subscriber received [30, 40, 50]. Pipeline: 6 items in &rarr; filter kept 4 &rarr; map transformed to [30,40,50,60] &rarr; take(3) cancelled after 3 &rarr; [30, 40, 50] delivered.';

        btn.disabled = false;
        pipelineRunning = false;
    }, 5500);
}

// ===== 6. ANIMATED EDS PIPELINE =====
let edsRunning = false;

function runEdsPipeline() {
    if (edsRunning) return;
    edsRunning = true;

    const btn = document.getElementById('runEds');
    const status = document.getElementById('edsStatus');
    btn.disabled = true;

    // Reset
    for (let i = 1; i <= 4; i++) {
        document.getElementById('eds-s' + i).classList.remove('active', 'done');
    }
    for (let i = 1; i <= 3; i++) {
        document.getElementById('eds-c' + i).classList.remove('done');
    }

    const stages = [
        { id: 'eds-s1', connector: null, status: 'Checking for running jobs...', duration: 1200 },
        { id: 'eds-s2', connector: 'eds-c1', status: 'Searching Azure Blob for newest file...', duration: 1500 },
        { id: 'eds-s3', connector: 'eds-c2', status: 'Parsing TSV, uploading batches (5 concurrent)...', duration: 2500 },
        { id: 'eds-s4', connector: 'eds-c3', status: 'Running mark-and-sweep, updating suggestions...', duration: 1500 }
    ];

    let delay = 300;
    stages.forEach((stage, i) => {
        // Activate stage
        setTimeout(() => {
            document.getElementById(stage.id).classList.add('active');
            status.textContent = stage.status;
            status.style.color = 'var(--accent)';
        }, delay);

        // Complete stage
        delay += stage.duration;
        setTimeout(() => {
            document.getElementById(stage.id).classList.remove('active');
            document.getElementById(stage.id).classList.add('done');
            if (stage.connector) {
                document.getElementById(stage.connector).classList.add('done');
            }

            // Change stage icon to checkmark
            const icon = document.getElementById(stage.id).querySelector('.stage-icon');
            icon.textContent = '\u2713';
        }, delay);
        delay += 200;
    });

    // Final success
    setTimeout(() => {
        status.textContent = 'Import complete! JobStatus.SUCCEEDED';
        status.style.color = 'var(--accent-green)';
        btn.disabled = false;
        edsRunning = false;

        // Reset icons after a delay
        setTimeout(() => {
            for (let i = 1; i <= 4; i++) {
                const icon = document.getElementById('eds-s' + i).querySelector('.stage-icon');
                icon.textContent = i;
            }
        }, 4000);
    }, delay);
}

// ===== 7. SMOOTH SCROLL FOR NAV LINKS =====
document.querySelectorAll('nav a[href^="#"]').forEach(link => {
    link.addEventListener('click', (e) => {
        e.preventDefault();
        const target = document.querySelector(link.getAttribute('href'));
        if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    });
});

// ===== 8. CODE BLOCK LINE HIGHLIGHT ON HOVER =====
// Adds a subtle line-by-line highlight effect when hovering over code
document.querySelectorAll('pre code').forEach(codeBlock => {
    codeBlock.addEventListener('mouseover', (e) => {
        // Natural hover glow is handled by CSS
    });
});

// ===== 9. AUTO-RUN FIRST VISIBLE DEMO =====
// When the pipeline demo scrolls into view, give a subtle pulse to the Run button
const demoBtnObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const btn = entry.target.querySelector('.demo-btn');
            if (btn && !btn.dataset.pulsed) {
                btn.dataset.pulsed = 'true';
                btn.style.animation = 'none';
                setTimeout(() => {
                    btn.style.animation = 'pulse-attention 2s ease-out';
                }, 500);
            }
        }
    });
}, { threshold: 0.5 });

document.querySelectorAll('.pipeline-demo, .lifecycle-demo, .eds-pipeline').forEach(el => {
    demoBtnObserver.observe(el);
});

// Pulse attention animation (injected dynamically)
const pulseStyle = document.createElement('style');
pulseStyle.textContent = `
    @keyframes pulse-attention {
        0%, 100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0); }
        25% { box-shadow: 0 0 0 8px rgba(88, 166, 255, 0.3); }
        50% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0); }
        75% { box-shadow: 0 0 0 6px rgba(88, 166, 255, 0.2); }
    }
`;
document.head.appendChild(pulseStyle);
</script>

</body>
</html>
